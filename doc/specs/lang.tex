\chapter{\us Language Specifications}
\label{sec:lang}

\section{Syntax}
\subsection{Comments}

\dfn{Comments} are used to document the code, they are ignored by the
\us interpreter. Both \Cxx comment types are supported.

\begin{itemize}
\item A \lstinline|//| introduces a comment that lasts until the end
  of the line.
\item A \lstinline|/*| introduces a comment that lasts until
  \lstinline|*/| is encountered. Comments nest, contrary to \C/\Cxx:
  if two \lstinline|/*| are encountered, the
  comment will end after two \lstinline|*/|, not one.
\end{itemize}

\begin{urbiscript}
// C++ style comment
/* C style comment */
/* These comments /* do */ nest */
\end{urbiscript}

\subsection{Identifiers}
\label{sec:us-syn-id}

\dfn{Identifiers} in \us are composed of one or more alphanumeric or
underscore (\lstinline|_|) characters, not starting by a digit, i.e.,
identifiers match the \lstinline|[a-zA-Z_][a-zA-Z0-9_]*| regular
expression.  Additionally, identifiers must not match any of the \us
reserved words\footnote{
%%
  The only exception to this rule is \lstinline|new|, which can be
  used as the method identifier in a method call.
%%
} documented in \autoref{sec:syn-key}. Identifiers can also be written
between simple quotes (\lstinline|'|), in which case they may contain
any character.

\begin{urbiscript}[firstnumber=last]
var x;
var foobar51;
var this.a_name_with_underscores;
// Invalid.
// var 3x;
// obj.3x();

// Invalid because "if" is a keyword.
// var if;
// obj.if();
// However, keywords can be escaped with simple quotes.
var 'if';
var this.'else';

// Identifiers can be escaped with simple quotes
var '%x';
var '1 2 3';
var this.'[]';
\end{urbiscript}

\subsection{Keywords}
\label{sec:syn-key}

\dfn{Keywords} are reserved words that cannot be used as identifiers,
for instance.  They are listed in \autoref{tab:keywords}.

\renewcommand{\baselinestretch}{.85}
\begin{table}[\floatpos]
  \centering
  \begin{tabular}{|c|c||c|c|}
    \hline
    Keyword                       & Remark                                  &
    Keyword                       & Remark                                  \\
    \hline
    \lstinline"and"               & Synonym for  operator                   &
    \lstinline"long"              & Reserved                                \\
    \lstinline"and_eq"            & Synonym for  operator                   &
    \lstinline"loop"              & \lstinline|loop&| and
                                    \lstinline-loop|- flavors               \\
    \lstinline"asm"               & Reserved                                &
    \lstinline"loopn"             & Deprecated, use \lstinline|for|         \\
    \lstinline"at"                &                                         &
    \lstinline"mutable"           & Reserved                                \\
    \lstinline"auto"              & Reserved                                &
    \lstinline"namespace"         & Reserved                                \\
    \lstinline"bitand"            & Synonym for \lstinline|&| operator      &
    \lstinline"new"               &                                         \\
    \lstinline"bitor"             & Synonym for \lstinline-|- operator      &
    \lstinline"not"               & Synonym for \lstinline|!| operator      \\
    \lstinline"bool"              & Reserved                                &
    \lstinline"not_eq"            & Synonym for \lstinline|!=| operator     \\
    \lstinline"break"             &                                         &
    \lstinline"object"            &                                         \\
    \lstinline"call"              &                                         &
    \lstinline"onleave"           &                                         \\
    \lstinline"case"              &                                         &
    \lstinline"or"                & Synonym for \lstinline-||- operator     \\
    \lstinline"catch"             & Reserved                                &
    \lstinline"or_eq"             & Synonym for \lstinline-|=- operator     \\
    \lstinline"char"              & Reserved                                &
    \lstinline"private"           & Ignored                                 \\
    \lstinline"class"             &                                         &
    \lstinline"protected"         & Ignored                                 \\
    \lstinline"closure"           &                                         &
    \lstinline"public"            & Ignored                                 \\
    \lstinline"compl"             & Synonym for \lstinline|~|               &
    \lstinline"register"          & Reserved                                \\
    \lstinline"const"             & Reserved                                &
    \lstinline"reinterpret_cast"  & Reserved                               \\
    \lstinline"const_cast"        & Reserved                                &
    \lstinline"return"            &                                         \\
    \lstinline"continue"          &                                         &
    \lstinline"short"             & Reserved                                \\
    \lstinline"default"           & Reserved                                &
    \lstinline"signed"            & Reserved                                \\
    \lstinline"delete"            &                                         &
    \lstinline"sizeof"            & Reserved                                \\
    \lstinline"do"                &                                         &
    \lstinline"static"            & Deprecated                              \\
    \lstinline"double"            & Reserved                                &
    \lstinline"static_cast"       & Reserved                                \\
    \lstinline"dynamic_cast"      & Reserved                                &
    \lstinline"stopif"            &                                         \\
    \lstinline"else"              &                                         &
    \lstinline"struct"            & Reserved                                \\
    \lstinline"emit"              & Deprecated                              &
    \lstinline"switch"            &                                         \\
    \lstinline"enum"              & Reserved                                &
    \lstinline"template"          & Reserved                                \\
    \lstinline"event"             &                                         &
    \lstinline"this"              &                                         \\
    \lstinline"every"             &                                         &
    \lstinline"throw"             & Reserved                                \\
    \lstinline"explicit"          & Reserved                                &
    \lstinline"timeout"           &                                         \\
    \lstinline"export"            & Reserved                                &
    \lstinline"try"               & Reserved                                \\
    \lstinline"extern"            & Reserved                                &
    \lstinline"typedef"           & Reserved                                \\
    \lstinline"external"          &                                         &
    \lstinline"typeid"            & Reserved                                \\
    \lstinline"float"             & Reserved                                &
    \lstinline"typename"          & Reserved                                \\
    \lstinline"for"               & \lstinline|for&| and \lstinline-for|- flavors&
    \lstinline"union"             & Reserved                                \\
    \lstinline"foreach"           & Deprecated, use \lstinline|for|    &
    \lstinline"unsigned"          & Reserved                                \\
    \lstinline"freezeif"          &                                         &
    \lstinline"using"             & Reserved                                \\
    \lstinline"friend"            & Reserved                                &
    \lstinline"var"               &                                         \\
    \lstinline"from"              &                                         &
    \lstinline"virtual"           & Reserved                                \\
    \lstinline"function"          &                                         &
    \lstinline"volatile"          & Reserved                                \\
    \lstinline"goto"              & Reserved                                &
    \lstinline"waituntil"         &                                         \\
    \lstinline"if"                &                                         &
    \lstinline"wchar_t"           & Reserved                                \\
    \lstinline"in"                &                                         &
    \lstinline"whenever"          &                                         \\
    \lstinline"inline"            & Reserved                                &
    \lstinline"while"             & \lstinline|while&| and
                                    \lstinline-while|- flavors              \\
    \lstinline"int"               & Reserved                                &
    \lstinline"xor"               & Synonym for \lstinline|^| operator      \\
    \lstinline"internal"          & Deprecated                              &
    \lstinline"xor_eq"            & Synonym \lstinline|^=| operator         \\
    \hline
  \end{tabular}
  \caption{Keywords}
  \label{tab:keywords}
\end{table}
\renewcommand{\baselinestretch}{1}

\subsection{Literals}
\subsubsection{Durations}

\dfn{Durations} are floats (see \autoref{sec:us-syn-lit-float})
followed by a time unit. They are simply equivalent to the same float,
expressed in seconds. For instance, \lstinline|1s 1ms|, which stands
for ``one second and 1 millisecond'', is strictly equivalent to
\lstinline|1.0001|. Available units and their equivalent are shown in
\autoref{tab:durations}.

\begin{table}[\floatpos]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    unit        & abbreviation & equivalence for $n$  \\
    \hline
    millisecond & ms           & $n / 1000$         \\
    second      & s            & $n$                \\
    minute      & mn           & $n \times 60$           \\
    hour        & h            & $n \times 60 \times 60$      \\
    day         & d            & $n \times 60 \times 60 \times 24$ \\
    \hline
  \end{tabular}
  \caption{Duration units}
  \label{tab:durations}
\end{table}

\subsubsection{Floats}
\label{sec:us-syn-lit-float}

Literal \dfn{floats} consist in a succession of digit, representing
the integral part of the number in decimal base, possibly followed by
a dot (\lstinline|.|) and another succession of digits representing
the decimal part. Briefly, float literals match the
\lstinline|[0-9]+(\.[0-9]+)?| regular
expression. The listing below is an example of literal
floats.  See \refObject{Float} for more details.

\begin{urbiscript}[firstnumber=last]
1;
[00000000] 1
1.1;
[00000000] 1.1
\end{urbiscript}

\subsubsection{Lists}
\label{sec:us-syn-lit-list}

Literal \dfn{lists} are represented with a comma-separated, potentially
empty list of arbitrary expressions enclosed in square brackets
(\lstinline|[]|), as shown in the listing below.  See
\refObject{List} for more details.

\begin{urbiscript}[firstnumber=last]
[]; // The empty list
[00000000] []
[1, 2, 3];
[00000000] [1, 2, 3]
\end{urbiscript}

\subsubsection{Strings}
\label{sec:us-syn-lit-string}

\dfn{String} literals are enclosed in double quotes (\lstinline|"|)
and can contain arbitrary characters, which stand for themselves, with
the exception of the escape character, backslash (\lstinline|\|), see
below.  Backslash introduces the following escapes:

\begin{tabular}{|c|p{.8\linewidth}|}
  \hline
  \lstinline|\\| & backslash             \\
  \lstinline|\a| & bell ring             \\
  \lstinline|\b| & backspace             \\
  \lstinline|\f| & form feed             \\
  \lstinline|\n| & line feed             \\
  \lstinline|\r| & carriage return       \\
  \lstinline|\t| & tabulation            \\
  \lstinline|\v| & vertical tabulation   \\

  \lstinline|\[0-7]{3}|
  & eight-bit character corresponding to a three-digit octal number.
  For instance, \lstinline|\000| and \lstinline|177|. \\

  \lstinline|\x[0-9a-fA-F]{2}|
  & eight-bit character corresponding to a two-digit hexadecimal
  number.  For instance, \lstinline|0xfF|. \\

  \lstinline|\B(\var{length})(\var{content})|
  & binary blob.  A \var{length}-long sequence of verbatim
  \var{content}.  \var{length} is expressed in decimal.  \var{content}
  is not interpreted in any way.  The parentheses below to the syntax,
  and are required.  For instance \lstinline|\B(2)(\B)|\\
  \hline
\end{tabular}

Consecutive string literals are glued together into a unique string.
This is useful to split large strings into chunks that fit usual
programming widths.

\begin{urbiscript}[firstnumber=last]
assert("foo" "bar" "baz" == "foobarbaz");
assert("\B(3)("\")" == "\"\\\"");
\end{urbiscript}

The interpreter prints the strings escaped; for instance, line feed
will be printed out as \lstinline|\n| when a string result is dumped
and so forth. An actual line feed will of course be output if a string
content is printed with echo for instance.

\begin{urbiscript}[firstnumber=last]
"";
[00000000] ""
"foo";
[00000000] "foo"
"a\nb"; // urbiScript escapes string when dumping them
[00000000] "a\nb"
echo("a\nb"); // We can see there is an actual line feed
[00000000] *** a
[:]b
echo("a\\nb");
[00000000] *** a\nb
\end{urbiscript}

See \refObject{String} for more details.

\subsection{Operators}

\us supports many \dfn{operators}, most of which are inspired from
\Cxx. Their syntax is presented here, and they are sorted and
described with their original semantics --- that is, \lstinline|+| is
an arithmetic operator that sums two numeric values. However, as in
\Cxx, these operators might be use for any other purpose --- that is,
\lstinline|+| can also be used as the concatenation operator on lists
and strings. Their semantics is thus not limited to what is presented
here.

Tables in this section sort operators top-down, by precedence order.
Group of rows (not separated by horizontal lines) describe operators
that have the same precedence. Many operators are syntactic sugar that
bounce on a method. In this case, the equivalent desugared expression
is shown in the ``Equivalence'' column. This can help you determine
what method to override to define an operator for an object (see
\autoref{sec:tut:operators}).

This section defines the syntax, precedence and associativity of the
operators. Their semantics is described in \autoref{sec:stdlib} in the
documentation of the classes that provide them.

% Operator generators
\newcommand{\operatorhead}{Operator & Use & Associativity & Original semantic
  & Equivalence\\}


\newcommand{\operator}[6][ ]{\lstinline@#2@&\lstinline@#3@&#4&#5&\lstinline@#6@#1\\}
\newcommand{\boperator}[3]{\operator{#1}{a #1 b}{#2}{#3}{a.'#1'(b)}}
\newcommand{\poperator}[3]{\operator{#1}{#1a}{#2}{#3}{a.'#1'()}}

\newcommand{\operatordot}    {\operator  {.}    {a.b}              {-}     {Message sending}          {Not redefinable}       }
\newcommand{\operatordota}   {\operator  {.}    {a.b(args)}        {-}     {Message sending}          {Not redefinable}       }
\newcommand{\operatorsub}    {\operator  {[]}   {a[args]}          {-}     {Subscript}                {a.'[]'(args)}          }
\newcommand{\operatorsubass} {\operator  {[] =} {a[args] = v}      {-}     {Subscript assignment}     {a.'[]='(args, v)}      }
\newcommand{\operatorass}[2][ ]    {\operator[#1]
                                         {=}    {a = b}            {Right} {Assignment}               {updateSlot("a", b)}    }

\newcommand{\operatoriass}[1]{\operator  {#1=}  {a #1= b}          {Right} {In place assignment}      {a = a #1 b}            }
\newcommand{\operatorsiass}  {
    \operatoriass{+}
    \operatoriass{-}
    \operatoriass{*}
    \operatoriass{/}
    \operatoriass{\%}
    \operatoriass{\^}
%    \operatoriass{\~}
}
\newcommand{\operatorinc}    {\operator  {++}   {a++}              {-}     {Incrementation}           {(a = a + 1) - 1}       }
\newcommand{\operatordec}    {\operator  {--}   {a--}              {-}     {Incrementation}           {(a = a - 1) + 1}       }

\newcommand{\operatoruplus}  {\poperator {+}    {-}                {Identity}               }
\newcommand{\operatorumin}   {\poperator {-}    {-}                {Opposite}               }
\newcommand{\operatorexp}    {\boperator {**}   {Right}            {Exponentiation}         }
\newcommand{\operatormult}   {\boperator {*}    {Left}             {Multiplication}         }
\newcommand{\operatordiv}    {\boperator {/}    {Left}             {Division}               }
\newcommand{\operatormod}    {\boperator {\%}   {Left}             {Modulo}                 }
\newcommand{\operatorplus}   {\boperator {+}    {Left}             {Sum}                    }
\newcommand{\operatorminus}  {\boperator {-}    {Left}             {Difference}             }
\newcommand{\operatorlshift} {\boperator {<<}   {Left}             {Left bit shift}         }
\newcommand{\operatorrshift} {\boperator {>>}   {Left}             {Right bit shift}        }
\newcommand{\operatoreq}     {\boperator {==}   {Non Associative}  {Equality}               }
\newcommand{\operatorneq}    {\boperator {!=}   {Non Associative}  {Inequality}             }
\newcommand{\operatorpeq}    {\boperator {===}  {Non Associative}  {Physical equality}      }
\newcommand{\operatorpneq}   {\boperator {!==}  {Non Associative}  {Physical Inequality}    }
\newcommand{\operatoraeq}    {\boperator {\~=}  {Non Associative}  {Relative Approximative equality} }
\newcommand{\operatoreqaeq}  {\boperator {=~=}  {Non Associative}  {Absolute Approximative equality} }
\newcommand{\operatorinf}    {\boperator {<}    {Non Associative}  {Less than}              }
\newcommand{\operatorinfeq}  {\boperator {<=}   {Non Associative}  {Less than or equal to}  }
\newcommand{\operatorsup}    {\boperator {>}    {Non Associative}  {Greater than}           }
\newcommand{\operatorsupeq}  {\boperator {>=}   {Non Associative}  {Greater than or equal to}}
\newcommand{\operatorbxor}   {\boperator {^}    {Left}             {Bitwise exclusive or}   }
\newcommand{\operatorneg}    {\poperator {!}    {Left}             {Logical negation}       }
\newcommand{\operatorand}    {\boperator {\&\&} {Left}             {Logical and}            }
\newcommand{\operatoror}     {\boperator {||}   {Left}             {Logical or}             }

\subsubsection{Arithmetic operators}

\us supports classic \dfn{arithmetic operators}, with the classic
semantics on numeric values. See the table and the listing below.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatoruplus
    \operatorumin
    \hline
    \operatorexp
    \hline
    \operatormult
    \operatordiv
    \operatormod
    \hline
    \operatorplus
    \operatorminus
    \hline
  \end{tabular}
  \caption{Arithmetic operators}
\end{table}

\begin{urbiscript}[firstnumber=last]
1 + 1;
[00000000] 2
1 - 2;
[00000000] -1
2 * 3;
[00000000] 6
10 / 2;
[00000000] 5
2 ** 10;
[00000000] 1024
-(1 + 2);
[00000000] -3
\end{urbiscript}

\subsubsection{Assignment operators}

\dfn{Assignment} in \us can be performed with the \lstinline|=|
operator.  Shorthands such as \lstinline|+=| exist; they are not
redefinable since they are equivalent to a regular assignment combined
with another operator. See the table and the listing below.


\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorass[\footnotemark]{}
    \operatorsiass
    \hline
  \end{tabular}
  \caption{Assignment operators}
\end{table}
\footnotetext{For object fields only. Assignment to local variables
  cannot be redefined. }

% FIXME: this in place modulo example was removed
%         because %= is a lame Urbi operator.
%  x %= 3;


\begin{urbiscript}[firstnumber=last]
var y = 0;
[00000000] 0
y = 10;
[00000000] 10
y += 10;
[00000000] 20
y /= 5;
[00000000] 4
y++;
[00000000] 4
y;
[00000000] 5
\end{urbiscript}

\subsubsection{Bitwise operators}

\us features \dfn{bitwise operators}.  They are also used for other
purpose than bit-related operations. See the table and the listing below.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorlshift
    \operatorrshift
    \hline
    \operatorbxor
    \hline
  \end{tabular}
  \caption{Bitwise operators}
\end{table}

\begin{urbiscript}[firstnumber=last]
4 << 2;
[00000000] 16
4 >> 2;
[00000000] 1
\end{urbiscript}

\subsubsection{Logical operators}

\us supports the usual \dfn{Boolean operators}. See the table and the
listing below. The operators \lstinline|&&| and \lstinline-||- are
short-circuiting: their right-hand side is evaluated only if needed.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatorneg
    \hline
    \operatorand
    \hline
    \operatoror
    \hline
  \end{tabular}
  \caption{Boolean operators}
\end{table}

\begin{urbiscript}[firstnumber=last]
true && true;
[00000000] true
true || false;
[00000000] true
!true;
[00000000] false
true || (1 / 0);
[00000000] true
false && (1 / 0);
[00000000] false
\end{urbiscript}

\subsubsection{Comparison operators}

\us supports classical \dfn{comparison operators}. See the table and the listing below.

\begin{table}[\floatposh]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatoreq
    \operatorneq
    \operatorpeq
    \operatorpneq
    \operatoraeq
    \operatoreqaeq
    \operatorinf
    \operatorinfeq
    \operatorsup
    \operatorsupeq
    \hline
  \end{tabular}
  \caption{Comparison operators}
\end{table}

\begin{urbiscript}[firstnumber=last]
0 < 0;
[00000000] false
0 <= 0;
[00000000] true
0 == 0;
[00000000] true
0 === 0;
[00000000] false
var z = 0;
[00000000] 0
z === z;
[00000000] true
z !== z;
[00000000] false
\end{urbiscript}

\subsubsection{Miscellaneous operators}

These operators do not fit the previous categories. See the table and
the listing below. Note that the \dfn[operator!subscript]{subscript}
(square bracket) operator is \dfn{variadic}: it takes any number of
arguments that will be passed to the \lstinline|'[]'| method of the
targeted object.

\begin{table}[\floatposh]
  \caption{Miscellaneous operators}
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \operatorhead
    \hline
    \operatordot
    \operatordota
    \hline
    \operatorsub
    \operatorsubass
    \hline
  \end{tabular}
\end{table}

\begin{urbiscript}[firstnumber=last]
// On lists.
var l = [1, 2, 3, 4, 5];
[00000000] [1, 2, 3, 4, 5]
l[0];
[00000001] 1
l[-1];
[00000002] 5
l[0] = 10;
[00000003] 10
l;
[00000004] [10, 2, 3, 4, 5]

// On strings.
var s = "abcdef";
[00000005] "abcdef"
s[0];
[00000006] "a"
s[1,3];
[00000007] "bc"
s[1,3] = "foo";
[00000008] "foo"
s;
[00000009] "afoodef"
\end{urbiscript}

\clearpage
\subsubsection{All operators summary}

\autoref{tab:operators-summary} is a summary of all operators, to
highlight the overall precedences. Operators are sorted by decreasing
precedence. Groups of rows represent operators with the same
precedence.

\begin{table}[\floatposh]
  \caption{Operators summary}
  \label{tab:operators-summary}
  \centering
  \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    Operator               & Use                                    & Associativity
    & Original semantic    & Equivalence                            \\
    \hline
    \operatordot
    \operatordota
    \hline
    \operatorsub
    \operatorsubass
    \hline
    \operatoruplus
    \operatorumin
    \hline
    \operatorexp
    \hline
    \operatormult
    \operatordiv
    \operatormod
    \hline
    \operatorplus
    \operatorminus
    \hline
    \operatorlshift
    \operatorrshift
    \hline
    \operatoreq
    \operatorneq
    \operatorpeq
    \operatorpneq
    \operatoreqaeq
    \operatoraeq
    \operatorinf
    \operatorinfeq
    \operatorsup
    \operatorsupeq
    \hline
    \operatorbxor
    \hline
    \operatorneg
    \hline
    \operatorand
    \hline
    \operatoror
    \hline
    \operatorass
    \operatorsiass
    \hline
    \operatorinc
    \operatordec
    \hline
  \end{tabular}

\end{table}


\section{Scopes and local variables}

\subsection{Scopes}

% FIXME: This is wrong: the last separator isn't ignored; a pipe voids
% the result, for instance.
\dfn{Scopes} are sequences of statements, enclosed in curly brackets
(\lstinline|{}|). Statements are separated with the four statements
separators (see \fixme{autoref{sec:fixme}}). The last separator is
optional and ignored if present. Scopes are themselves expressions,
and can thus be used in composite expressions, nested, and so forth.

\begin{urbiscript}[firstnumber=last]
// Scopes evaluate to their last expression
{
  1;
  2;
  3; // This last separator is optional.
};
[00000000] 3
// Scopes can be used as expressions
{1; 2; 3} + 1;
[00000000] 4
\end{urbiscript}

\subsection{Local variables}

\dfn{Local variables} are introduced with the \lstinline|var| keyword,
followed by an identifier (see \autoref{sec:us-syn-id}) and an optional
initialization value assignment. If the initial value is omitted, it
defaults to \refObject{void}. Variable
declarations evaluate to
the initialization value. They can later be referred to by their
name. Their value can be changed with the assignment operator; such an
assignment expression returns the new value. The use of local
variables is illustrated below.

\begin{urbiscript}[firstnumber=last]
// This declare variable x with value 42, and evaluates to 42.
var t = 42;
[00000000] 42
// x equals 42
t;
[00000000] 42
// We can assign it a new value
t = 51;
[00000000] 51
t;
[00000000] 51
// Initialization defaults to void
var u;
u.isVoid;
[00000000] true
\end{urbiscript}

The lifespan of local variables is the same as their enclosing scope. They
are thus only accessible from their scope and its
subscopes\footnote{Local variables can actually escape their scope
  with lexical closures, see \autoref{sec:us-fun-closures}.}. Two
variables with the same name cannot be defined in the same scope. A
variable with the same name can be defined in an inner scope, in which
case references refer to the innermost variable, as shown below.

\begin{urbiscript}[firstnumber=last]
{
  var x = "x";
  var y = "outer y";
  {
    var y = "inner y";
    var z = "z";
    // We can access variables of parent scopes.
    echo(x);
    // This refers to the inner y.
    echo(y);
    echo(z);
  };
  // This refers to the outer y.
  echo(y);
  // This would be invalid: z does not exist anymore.
  // echo(z);
  // This would be invalid: x is already declared in this scope.
  // var x;
};
[00000000] *** x
[00000000] *** inner y
[00000000] *** z
[00000000] *** outer y
\end{urbiscript}


\section{Functions}

\subsection{Function Definition}

\dfn{Functions} in \us are first class citizens: a function is a
value, like floats and strings, and can be handled as such.  This is
different from most \C-like languages.  One can create a functional
value thanks to the \lstinline|function| keyword, followed by the list
of formal arguments and a compound statement representing the body of
the function. Formal arguments are a possibly-empty comma-separated
list of identifiers.  Non-empty lists of formal arguments may
optionaly end with a trailing comma. The listing below illustrates
this.

\begin{urbiscript}[firstnumber=last]
function () { echo(0) };
[00000000] function () {
[:]  echo(0)
[:]}

function (arg1, arg2) { echo(0) };
[00000000] function (arg1, arg2) {
[:]  echo(0)
[:]}

function (
           arg1, // Ignored argument.
           arg2, // Also ignored.
          )
{
  echo(0)
};
[00000000] function (arg1, arg2) {
[:]  echo(0)
[:]}
\end{urbiscript}

Usually functions are bound to an identifier to be invoked later.
The listing below shows a short-hand to define a named
function.

\begin{urbiscript}[firstnumber=last]
// Functions are often stored in variables to call them later.
var f1 = function () {
  echo("hello")
}|
f1();
[00000000] *** hello

// This form is strictly equivalent, yet simpler.
function f2()
{
  echo("hello")
}|
f2();
[00000000] *** hello
\end{urbiscript}


\subsection{Arguments}

The list of formal arguments defines the number of argument the
function requires. They are accessible by their name from within the
body. If the list of formal arguments is omitted, the number of
effective arguments is not checked, and arguments themselves are not
evaluated. Arguments can then be manipulated with the call message,
explained below.

\begin{urbiscript}[firstnumber=last]
var f = function(a, b) {
  echo(b + a);
}|
f(1, 0);
[00000000] *** 1
// Calling a function with the wrong number of argument is an error.
f(0);
[00000000:error] !!! f: Expected 2 arguments, given 1
f(0, 1, 2);
[00000000:error] !!! f: Expected 2 arguments, given 3
\end{urbiscript}

Non-empty lists of effective arguments may end with an optional comma.
\begin{urbiscript}[firstnumber=last]
f(
  "bar",
  "foo",
 );
[00000000] *** foobar
\end{urbiscript}


\subsection{Return value}

The \dfn[function!return value]{return value} of the function is the
evaluation of its body --- that is, since the body is a scope, the
last evaluated expression in the scope.  Values can be returned
manually with the \lstinline|return| keyword followed by the value, in
which case the evaluation of the function is stopped. If
\lstinline|return| is used with no value, the function returns
\lstinline|void|.

\begin{urbiscript}[firstnumber=last]
function g1(a, b)
{
  echo(a);
  echo(b);
  a // Return value is a
}|
g1(1, 2);
[00000000] *** 1
[00000000] *** 2
[00000000] 1

function g2(a, b)
{
  echo(a);
  return a; // Stop execution at this point and return a
  echo(b); // This is not executed
}|
g2(1, 2);
[00000000] *** 1
[00000000] 1

function g3()
{
  return; // Stop execution at this point and return void
  echo(0); // This is not executed
}|
g3(); // Returns void, so nothing is printed.
\end{urbiscript}

\subsection{Call messages}
\label{sec:us-fun-callmsg}

Functions can access meta-information about how they were called,
through a \lstinline|CallMessage| object. The \dfn{call message}
associated with a function can be accessed with the \lstinline|call|
keyword. It contains several information such as not-yet evaluated
arguments, the name of the function, the target \ldots

\subsection{Strictness}

\us features two different function calls:
\dfn[function!strict]{strict} function calls, effective arguments are
evaluated before invoking the function, and \dfn[function!lazy]{lazy}
function calls, arguments are passed as-is to the function.  As a
matter of fact, the difference is rather that there are strict
functions and lazy function.

Functions defined with a (possibly empty) list of formal arguments in
parentheses are strict: the effective arguments are first evaluated,
and then their value is given to the called function.

\begin{urbiscript}[firstnumber=last]
function first1(a, b) {
  echo(a); echo(b)
}|
first1({echo("Arg1"); 1},
       {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** Arg2
[00000000] *** 1
[00000000] *** 2
\end{urbiscript}

A function declared with no formal argument list is lazy.  Use its
call message to manipulate its \emph{unevaluated} arguments.
The listing below gives an example.  More information about
this can be found in the \refObject{CallMessage} class documentation.

\begin{urbiscript}[firstnumber=last]
function first2
{
  echo(call.evalArgAt(0));
  echo(call.evalArgAt(1));
}|
first2({echo("Arg1"); 1},
       {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** 1
[00000000] *** Arg2
[00000000] *** 2
\end{urbiscript}

A lazy function may implement a strict interface by evaluating its
arguments and storing them as local variables, see below.  This is
less efficient than defining a strict function.

\begin{urbiscript}[firstnumber=last]
function first3
{
  var a = call.evalArgAt(0);
  var b = call.evalArgAt(1);
  echo(a); echo(b);
}|
first3({echo("Arg1"); 1},
       {echo("Arg2"); 2});
[00000000] *** Arg1
[00000000] *** Arg2
[00000000] *** 1
[00000000] *** 2
\end{urbiscript}

\subsection{Lexical closures}
\label{sec:us-fun-closures}

\dfn{Lexical closures} are an additional scoping rule, with which a function
can refer to a local variable located outside the function --- but still
in the current context. \us supports read/write lexical closures,
meaning that the variable is shared between the function and the outer
environment, as shown below.

\begin{urbiscript}[firstnumber=last]
var n = 0|
function cl()
{
  // x refers to a variable outside the function
  n++;
  echo(n);
}|
cl();
[00000000] *** 1
n;
[00000000] 1
n++;
[00000000] 1
cl();
[00000000] *** 3
\end{urbiscript}

The following listing illustrate that local variables can even
escape their declaration scope by lexical closure.

\begin{urbiscript}[firstnumber=last]
function wrapper()
{
  // Normally, x is local to 'wrapper', and is limited to this scope.
  var x = 0;
  at (x > 1)
    echo("ping");
  // Here we make it escape the scope by returning a closure on it.
  return function() { x++ };
} |
[00000001:warning] !!! expensive feature: at (<expression>), prefer at (<event>)

var w = wrapper()|
w();
[00000000] 0
w();
[00000000] 1
[00000000] *** ping
\end{urbiscript}

See \autoref{sec:faq:atexp} for more details about the warning.


\section{Objects}

Any value in \us is an object. Objects contain:

\begin{itemize}
\item A list of prototypes, which are also objects.
\item A list of slots, which to a name associate an object.
\end{itemize}

\subsection{Slots}

\subsubsection{Manipulation}

\dfn{Objects} can contain any number of \dfn{slots}, every slot has a
name and a value. Slots are often called ``fields'', ``attributes'' or
``members'' in other object-oriented languages.

The \lstinline|createSlot| function adds a slot to an object with the
void (\autoref{sec:std-void}) value. The \lstinline|updateSlot|
function changes the value of a slot; \lstinline|getSlot| reads
it. The \lstinline|setSlot| method creates a slot with a given
value. Finally, the \lstinline|localSlotNames| method returns the list of
the object slot's name. The listing below shows how to manipulate
slots. More documentation about these methods can be found in
\autorefObject{Object}.

\begin{urbiscript}[firstnumber=last]
var o = Object.new|
o.localSlotNames;
[00000000] []
o.createSlot("test");
o.localSlotNames;
[00000000] ["test"]
o.getSlot("test").asString;
[00000000] "void"
o.updateSlot("test", 42);
[00000000] 42
o.getSlot("test");
[00000000] 42
\end{urbiscript}

\subsubsection{Syntactic Sugar}

There is some syntactic sugar for slot methods:
\begin{itemize}
\item \lstinline|var o.name| is equivalent to
  \lstinline|o.createSlot("name")|.
\item \lstinline|var o.name = value| is equivalent to
  \lstinline|o.setSlot("name", value)|.
\item \lstinline|o.name = value| is equivalent to
  \lstinline|o.updateSlot("name", value)|.
\end{itemize}


\subsection{Prototypes}

\subsubsection{Manipulation}

\us is a prototype-based language, unlike most classical object
oriented language, which are class-based. In prototype-based
languages, objects have no type, only \dfn{prototypes}, from which they
inherit behavior.

\us objects can have several prototypes. The list of prototypes is
given by the \lstinline|protos| method; they can be added or removed
with \lstinline|addProto| and \lstinline|removeProto|.  See
\autorefObject{Object} for more documentation.

\begin{urbiscript}[firstnumber=last]
var ob = Object.new|
ob.protos;
[00000000] [Object]
ob.addProto(Pair);
[00000000] (nil, nil)
ob.protos;
[00000000] [(nil, nil), Object]
ob.removeProto(Object);
[00000000] (nil, nil)
ob.protos;
[00000000] [(nil, nil)]
\end{urbiscript}

\subsubsection{Inheritance}

Objects inherit their prototypes' slots: \lstinline|getSlot| will also
look in an object prototypes' slots. \lstinline|getSlot| performs a
depth-first traversal of the prototypes hierarchy to find slots. That
is, when looking for a slot in an object:

\begin{itemize}
\item \lstinline|getSlot| checks first if the object itself has the
  requested slot. If so, it returns its value.
\item Otherwise, it applies the same research on every prototype, in
  the order of the prototype list (since addProto inserts in the front
  of the prototype list, the last prototype added has priority). This
  search is recursive: \lstinline|getSlot| will also look in the first
  prototype's prototype, etc before looking in the second
  prototype. If the slot is found in a prototype, it is returned.
\item Finally, if no prototype had the slot, an error is raised.
\end{itemize}

This listing shows how slots are inherited.

\begin{urbiscript}[firstnumber=last]
var a = Object.new|
var b = Object.new|
var c = Object.new|
a.setSlot("x", "slot in a")|
b.setSlot("x", "slot in b")|
// c has no "x" slot
c.getSlot("x");
[00000000:error] !!! lookup failed: x
// c can inherit the "x" slot from a.
c.addProto(a)|
c.getSlot("x");
[00000000] "slot in a"
// b is prepended to the prototype list, and has thus priority
c.addProto(b)|
c.getSlot("x");
[00000000] "slot in b"
// a local slot in c has priority over prototypes
c.setSlot("x", "slot in c")|
c.getSlot("x");
[00000000] "slot in c"
\end{urbiscript}

\subsubsection{Copy on write}

The \lstinline|updateSlot| method has a particular behavior with
respect to prototypes. Although performing an \lstinline|updateSlot|
on a non existent slot is an error, it is valid if the slot is
inherited from a prototype. In this case, the slot is however not
updated in the prototype, but rather created in the object itself,
with the new value. This process is called \dfn{copy on write}; thanks
to it, prototypes are not altered when the slot is overridden in a
child object.

\begin{urbiscript}[firstnumber=last]
var p = Object.new|
var p.slot = 0|
var d = Object.new|
d.addProto(p)|
d.slot;
[00000000] 0
d.slot = 1;
[00000000] 1
// p's slot was not altered
p.slot;
[00000000] 0
// It was copied in d
d.slot;
[00000000] 1
\end{urbiscript}

\subsection{Sending messages}

A \dfn{message} in \us consists in a message name and arguments. One can
send a message to an object with the dot (\lstinline|.|) operator,
followed by the message name (which can be any valid identifier) and
the arguments, as shown below. When there are no
arguments, the parentheses can be omitted. As you might see,
sending messages is very similar to calling methods in classical
languages.

\begin{urbifixme}
// Send the message msg to object obj, with arguments arg1 and arg2.
obj.msg(arg1, arg2);
// Send the message msg to object obj, with no arguments.
obj.msg();
// This is strictly equivalent.
obj.msg;
\end{urbifixme}

When a message ``msg'' is sent to object \lstinline|obj|:

\begin{itemize}
\item The ``msg'' slot of \lstinline|obj| is retrieved (i.e.,
  \lstinline|obj.getSlot("msg")|). If the slot is not found, the
  classic lookup error is raised.
\item If the object is not a \lstinline|Routine|
  (\fixme{autoref{sec:fixme}}), it's
  the result of the message sending. In this case, there must be no
  argument, otherwise an error is raised.
\item If the object is a \lstinline|Routine|, it is invoked with the
  message sending arguments, and the returned value is the result. As
  a consequence, the number of arguments in the message sending must
  match the one required by the \lstinline|Routine|.
\end{itemize}

Such message sending is illustrated below.

\begin{urbiscript}[firstnumber=last]
var obj = Object.new|
var obj.a = 42|
var obj.b = function (x) { x + 1 }|
obj.a;
[00000000] 42
obj.a();
[00000000] 42
obj.a(50);
[00000000:error] !!! a: Expected 0 argument, given 1
obj.b;
[00000000:error] !!! b: Expected 1 argument, given 0
obj.b();
[00000000:error] !!! b: Expected 1 argument, given 0
obj.b(50);
[00000000] 51
\end{urbiscript}

\section{Imperative flow control}

\subsection{break}

When encountered within a \lstinline|for| or a \lstinline|while| loop,
\lstinline|break| makes the execution jump after the loop.

\begin{urbiscript}[firstnumber=last]
var i = 5|
for (; true; echo(i))
{
  if (i > 8)
    break;
  i++;
};
[00000000] *** 6
[00000000] *** 7
[00000000] *** 8
[00000000] *** 9
\end{urbiscript}

\subsection{continue}

When encountered within a \lstinline|for| or a \lstinline|while| loop,
\lstinline|continue| short-circuits the rest of the loop-body, and
runs the next iteration (if there remains one).

\begin{urbiscript}[firstnumber=last]
for (var i = 0; i < 8; i++)
{
  if (i % 2 != 0)
    continue;
  echo(i);
};
[00000000] *** 0
[00000000] *** 2
[00000000] *** 4
[00000000] *** 6
\end{urbiscript}

\subsection{do}

The \lstinline|do| construct changes the target (\lstinline|this|)
when evaluating an expression.  It is a convenient means to avoid
repeating the same target several times.

\begin{urbifixme}[frame=, backgroundcolor=, ]
do (\var{target})
{
  \var{body}
};
\end{urbifixme}

It evaluates \var{body}, with \lstinline|this| being \var{target}, as
shown below.  The whole construct evaluates to the value
of \var{body}.

\begin{urbiscript}[firstnumber=last]
do (1024)
{
  assert(this == 1024);
  assert(sqrt == 32);
  setSlot("y", 23);
}.y;
[00000000] 23
\end{urbiscript}


\subsection{if}
\label{sec:lang:if}
As in most programming languages, conditionals are expressed with
\lstinline|if|.

\begin{urbifixme}[frame=, backgroundcolor=, ]
if (\var{condition}) \var{then-clause}
if (\var{condition}) \var{then-clause} else \var{else-clause}
\end{urbifixme}

First \var{condition} is evaluated; if if evaluates to a value which
is true (\fixme{point to a definition of truth values}), evaluate
\var{then-clause}, otherwise, if applicable, evaluate
\var{else-clause}.

\begin{urbiscript}[firstnumber=last]
if (true) assert(true) else assert(false);
if (false) assert(false) else assert(true);
if (true) assert(true);
\end{urbiscript}

Beware that \emph{there must not be a terminator after the
  \var{then-clause}}:

\begin{urbiscript}[firstnumber=last]
if (true)
  assert(true);
else
  assert(false);
[00000002:error] !!! syntax error, unexpected else
\end{urbiscript}

Contrary to \C/\Cxx, it has value: it also implements the
\lstinline|\var{condition} ? \var{then-clause} : \var{else-clause}|
construct.  Unfortunately, due to syntactic constraints inherited from
\C, it is a \emph{statement}: it cannot be used directly as an
expression.  But as everywhere else in \us, to use a statement where
an expression is expected, use braces:

\begin{urbiscript}[firstnumber=last]
assert(1 + if (true) 3 else 4 == 4);
[00000003:error] !!! syntax error, unexpected if
assert(1 + { if (true) 3 else 4 } == 4);
\end{urbiscript}

The \var{condition} can be any statement list.  Variables which it
declares are visible in both the \var{then-clause} and the
\var{else-clause}, but do not escape the \lstinline|if| construct.

\begin{urbiscript}[firstnumber=last]
assert({if (false) 10 else 20} == 20);
assert({if (true)  10 else 20} == 10);

assert({if (true) 10         } == 10);

assert({if (var x = 10) x + 2 else x - 2} == 12);
assert({if (var x = 0)  x + 2 else x - 2} == -2);

if (var xx = 123) xx | xx;
[00000005:error] !!! lookup failed: xx
\end{urbiscript}

\subsection{for}
\label{sec:lang:for}
\lstinline|for| comes in several flavors.

\subsubsection{C-like for}

\us support the classical \C-like \lstinline|for| construct.

\begin{urbifixme}[frame=, backgroundcolor=, ]
for (\var{initialization}; \var{condition}; \var{increment})
  \var{body}
\end{urbifixme}

It has the exact same behavior as \C's \lstinline|for|:

\begin{enumerate}
\item The \var{initialization} is evaluated.
\item \var{condition} is evaluated. If the result is false, executions
  jump after \lstinline|for|.
\item \var{body} is evaluated. If \lstinline|continue| is encountered,
  execution jumps to point 4. If \lstinline|break| is encountered,
  executions jumps after the \lstinline|for|.
\item The \var{increment} is evaluated.
\item Execution jumps to point 2.
\item The loop evaluates to \lstinline|void|.
\end{enumerate}

\subsubsection{for in}
\label{sec:lang:for:each}

\us supports iteration over a collection with another form of the
\lstinline|for| loop.

\begin{urbifixme}[frame=, backgroundcolor=, ]
for (var \var{name} in \var{collection})
   \var{body};
\end{urbifixme}

It evaluates \var{body} for each element in \var{collection}. The loop
evaluates to \lstinline|void|.  Inside \var{body}, the current element
is accessible via the \var{name} local variable. The listing below
illustrates this.

\begin{urbiscript}[firstnumber=last]
for (var x in [0, 1, 2, 3, 4])
  echo(x.sqr);
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
[00000000] *** 9
[00000000] *** 16
\end{urbiscript}

This form of \lstinline|for| simply sends the \lstinline|each| message
to \var{collection} with one argument: the function that takes the
current element and performs \lstinline|action| over it. Thus, you can
make any object acceptable in a \lstinline|for| by defining an
adequate \lstinline|each| method.

\begin{urbiscript}[firstnumber=last]
var Hobbits = Object.new|
function Hobbits.each (action)
{
  action("Frodo");
  action("Merry");
  action("Pippin");
  action("Sam");
}|
for (var name in Hobbits)
  echo("%s is a hobbit." % [name]);
[00000000] *** Frodo is a hobbit.
[00000000] *** Merry is a hobbit.
[00000000] *** Pippin is a hobbit.
[00000000] *** Sam is a hobbit.
// This for statement is equivalent to:
Hobbits.each(function (name) { echo("%s is a hobbit." % [name]) });
[00000000] *** Frodo is a hobbit.
[00000000] *** Merry is a hobbit.
[00000000] *** Pippin is a hobbit.
[00000000] *** Sam is a hobbit.
\end{urbiscript}

\subsubsection{for $n$-times}
\label{sec:lang:for:n}

\us provides some support for simple replication of computations: it
allow to repeat a loop body $n$-times.  With the exception that the
loop index is not available within the body, \lstinline|for (n)| is
equivalent to \lstinline|for (var i: n)|.  It supports the same
flavors: \lstinline|for;|, \lstinline{for|}, and \lstinline|for&|. The
loop evaluates to \lstinline|void|.

\begin{urbiscript}[firstnumber=last]
assert({ var res = []; for (3) { res << 1; res << 2 } ; res }
        == [1, 2, 1, 2, 1, 2]);

assert({ var res = []; for|(3) { res << 1; res << 2 } ; res }
        == [1, 2, 1, 2, 1, 2]);

assert({ var res = []; for&(3) { res << 1; res << 2 } ; res }
        == [1, 1, 1, 2, 2, 2]);
\end{urbiscript}

Note that since these \lstinline|for| loops are merely anynomous
foreach-style loops, the argument needs not being an integer, any
iterable value can be used.

\begin{urbiscript}[firstnumber=last]
assert(3 == { var r = 0; for ([1, 2, 3]) r += 1; r});
assert(3 == { var r = 0; for ("123")     r += 1; r});
\end{urbiscript}


\subsection{if}

\us supports the usual \lstinline|if| constructs.

\begin{urbifixme}[frame=, backgroundcolor=, ]
if (\var{condition})
  \var{action};

if (\var{condition})
  \var{action}
else
  \var{otherwise};
\end{urbifixme}

If the \var{condition} evaluation is true, \var{action} is
evaluated. Otherwise, in the latter version, \var{otherwise} is
executed.  Contrary to \C/\Cxx, there \emph{must not} be a semicolon
after the \var{action}; it would end the
\lstinline|if|/\lstinline|else| construct prematurely.

\subsection{loop}

Endless loops can be created with \lstinline|loop|, which is
equivalent to \lstinline|while (true)|.  The loop evaluates to
\lstinline|void|.

\begin{urbiscript}[firstnumber=last]
var v = 1 |
loop
{
  v *= 2;
  if (1024 <= v)
    break;
};
v;
[00000000] 1024
\end{urbiscript}

\subsection{switch}

The \lstinline|switch| statement in \us is similiar to \C's one.

\begin{urbifixme}[frame=, backgroundcolor=, ]
switch (\var{value})
{
  case \var{value_one}:
    \var{action_one};
  case \var{value_two}:
    \var{action_two};
//case ...:
//  ...
  default:
    \var{default_action};
};
\end{urbifixme}

It might contain an arbitrary number of cases, and optionally a
default case. The \var{value} is evaluated first, and then the
result is compared sequentially with the evaluation of all cases
values, with the \lstinline|==| operator, until one comparison is
true. If such a match is found, the corresponding action is executed,
and execution jumps after the \lstinline|switch|. Otherwise, the
default case --- if any --- is executed, and execution jumps after the
switch. The switch itself evaluates to case that was evaluated, or to
void if no match was found and there's no default case. The listing below
illustrates \lstinline|switch| usage.

Unlike \C, there are no \lstinline|break| to end \lstinline|case|
clauses: execution will never span over several cases.  Since the
comparisons are performed with the generic \lstinline|==| operator,
\lstinline|switch| can be performed on any comparable data type.

\begin{urbiscript}[firstnumber=last]
function sw(v)
{
  switch (v)
  {
    case "":
      echo("Empty string");
    case "foo":
      "bar";
    default:
      v[0];
  }
} | {};
sw("");
[00000000] *** Empty string
sw("foo");
[00000000] "bar"
sw("foobar");
[00000000] "f"
\end{urbiscript}
% $ Pacify emacs math mode.

\subsection{while}

The \lstinline|while| loop is similar to \C's one.

\begin{urbifixme}[frame=, backgroundcolor=, ]
while (\var{condition})
  \var{body};
\end{urbifixme}

If \var{condition} evaluation, is true, \var{body} is evaluated and
execution jumps before the \lstinline|while|, otherwise execution
jumps after the \lstinline|while|.

\begin{urbiscript}[firstnumber=last]
var j = 3|
while (0 < j)
{
  echo(j);
  j--;
};
[00000000] *** 3
[00000000] *** 2
[00000000] *** 1
\end{urbiscript}


\section{Exceptions}

\subsection{Throwing exceptions}

Use the \lstinline|throw| keyword to \dfn[exception!throwing]{throw
  exceptions}, as shown below. Thrown exceptions will
break the execution upward until they are caught, or until they reach
the toplevel --- as in \Cxx.  Contrary to \Cxx, exceptions reaching
the toplevel are printed, and won't abort the kernel --- other and new
connections will continue to execute normally.

\begin{urbiscript}[firstnumber=last]
throw 42;
[00000000:error] !!! 42
function inner() { throw "exn" } |
function outer() { inner() }|
// Exceptions propagate to parent call up to the toplevel
outer();
[00000000:error] !!! exn
[00000000:error] !!!    called from: 3.20-26: inner
[00000000:error] !!!    called from: 4.1-7: outer
\end{urbiscript}

\subsection{Catching exceptions}

Exceptions are \dfn[exception!catching]{caught} with the
\lstinline|try|/\lstinline|catch| construct. It consists of a first
block (the \dfn{try-block}), from which we want to catch exceptions,
and one or more catch clauses to stop the exception
(\dfn{catch-blocks}). Each catch clause defines a pattern against
which the thrown exception is matched. If no pattern is specified, the
catch clause matches systematically (equivalent to
\lstinline|catch (...)| in \Cxx).

Exceptions thrown from the \texttt{try} block are matched sequentially
against all catch clauses. The first matching clause is executed, and
control jumps after the whole try/catch block. If no catch clause
matches, the exceptions isn't stopped and continues
upward.

\begin{urbiscript}[firstnumber=last]
function test(e)
{
  try
  { throw e;  }
  catch (0)
  { echo("zero") }
  catch ([var x, var y])
  { echo(x + y) }
} | {};
test(0);
[00002126] *** zero
test([22, 20]);
[00002131] *** 42
test(51);
[00002143:error] !!! 51
[00002143:error] !!!    called from: 12.1-8: test

\end{urbiscript}

\subsection{Inspecting exceptions}

\subsection{Exceptions and parallelism}




\section{Parallel and event-based flow control}

\subsection{at}

\subsection{every}

The \lstindex{every} statement enables to execute a block of code
repeatedly, with the given period.

\begin{urbiscript}[firstnumber=last]
// Print out a message every second.
every (1s)
  echo("Are you still there?");
/*(*/sleep(2.1s);/*)*/
[00000000] *** Are you still there?
[00001000] *** Are you still there?
[00002000] *** Are you still there?
\end{urbiscript}

It exists in two flavors. The default flavor launches the execution of
the block in the background every given period. Iterations may
overlap.

% Cut the previous every, no [firstnumber=last]
\begin{urbiscript}
// If an iteration is longer than the given period, it will overlap
// with the next one.
every (1s)
{
  echo("In");
  sleep(1.5s);
  echo("Out");
};
/*(*/sleep(2.6s);/*)*/
[00000000] *** In
[00001000] *** In
[00001500] *** Out
[00002000] *** In
[00002500] *** Out
\end{urbiscript}

On the other hand, the \lstindex{every|} flavor will not let
iterations overlap. If an iteration takes too long, the following
iterations are delayed. That is, the next iterations will start
immediately after the end of the current one, and next iterations will
occur normally from this point.

% Cut the previous every, no [firstnumber=last]
\begin{urbiscript}
var too_long = true|;

// Every other iteration exceeds the period, and will delay the
// following one.
every| (1s)
{
  if (too_long)
  {
    too_long = false;
    echo("Long in");
    sleep(1.5s);
    echo("Long out");
  }
  else
  {
    too_long = true;
    echo("Short");
  }
};
/*(*/sleep(4.1s);/*)*/
[00000000] *** Long in
[00001500] *** Long out
[00001500] *** Short
[00002500] *** Long in
[00004000] *** Long out
[00004000] *** Short
\end{urbiscript}

The flow-control constructs \lstinline|break| and \lstinline|continue|
are supported.

% Cut the previous every, no [firstnumber=last]
\begin{urbiscript}
{
  var count = 0;
  every| (250ms)
  {
    count += 1;
    if (count == 2)
      continue;
    if (count == 4)
      break;
    echo(count);
  }
};
/*(*/sleep(2s);/*)*/
[00000000] *** 1
[00001500] *** 3
\end{urbiscript}

\subsection{for\& (:)}
\subsection{for\& (n)}
\subsection{waituntil}
\subsection{whenever}


\section{Pattern matching}

\section{Trajectories}

% Local Variables:
%%% mode: latex
%%% TeX-master: "urbi-specs"
%%% End:
