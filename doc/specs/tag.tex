\section{Tag}

A Tag is an object which you can use to label blocks of code in order
to control them externally.  Tagged code can be freezed, resumed,
stopped\ldots See also \autoref{sec:tut:tags}.

\subsection{Construction}
\label{stdlib:tag:ctor}

Tags are objects, and must be created as any object by using
\lstinline{new} to create derivatives of the \lstinline{Tag} object.
The name is optional, it makes easier to display a tag and remember
what it is.

\begin{urbiscript}
// Anonymous tag.
var t1 = Tag.new;
[00000001] Tag<tag_8>

// Named tag.
var t2 = Tag.new("cool name");
[00000001] Tag<cool name>
\end{urbiscript}

\subsection{Examples}

\subsubsection{Stop}
\label{sec:specs:tag:stop}

To \dfn{stop} a tag means to kill all the code currently running that
it labels.  It does not affect ``newcomers''.

\begin{urbiscript}
var t = Tag.new|;
var t0 = time|;
t: every(1s) echo("foo"),
sleep(2.2s);
[00000158] *** foo
[00001159] *** foo
[00002159] *** foo

t.stop;
// Nothing runs.
sleep(2.2s);

t: every(1s) echo("bar"),
sleep(2.2s);
[00000158] *** bar
[00001159] *** bar
[00002159] *** bar

t.stop;
\end{urbiscript}

\lstinline|System.stop| can be used to inject a return value to a
tagged expression.

\begin{urbiscript}
var t = Tag.new|;
var res;
detach(res = { t: every(1s) echo("computing") });
sleep(2.2s);
[00000001] *** computing
[00000002] *** computing
[00000003] *** computing

t.stop("result");
assert(res == "result");
\end{urbiscript}

Be extremely cautious, as of today the precedence rules are
misleading: \lstinline|\var{var} = \var{tag}: \var{exp}| is read as
\lstinline|(\var{var} = \var{tag}): \var{exp}| (i.e., defining
\var{var} as an alias to \var{tag} and using it to tag \var{exp}), not as
\lstinline|\var{var} = { \var{tag}: \var{exp} }|.  Contrast the
following example, which is most probably an error from the user, with
the previous, correct, one.

\begin{urbiscript}
var t = Tag.new("t")|;
var res;
res = t: every(1s) echo("computing"),
sleep(2.2s);
[00000001] *** computing
[00000002] *** computing
[00000003] *** computing

t.stop("result");
assert(res == "result");
[00000004:error] !!! failed assertion: res == "result" (Tag<t> != "result")
\end{urbiscript}


\subsubsection{Block/unblock}
\label{sec:specs:tag:block}

To \dfn{block} a tag means:
\begin{itemize}
\item Stop running pieces of code it labels (as with
  \lstinline|Tag.stop|).
\item Ignore new pieces of code it labels (this differs from
  \lstinline|Tag.stop|).
\end{itemize}

One can \dfn{unblock} the tag.  Contrary to
\lstinline|freeze|/\lstinline|unfreeze|, tagged code does not resume
the execution.

\begin{urbiscript}
var ping = Tag.new("ping")|;
ping:
  every (1s)
    echo("ping"),
assert(!ping.blocked);
sleep(2.1s);
[00000000] *** ping
[00002000] *** ping
[00002000] *** ping

ping.block;
assert(ping.blocked);

ping:
  every (1s)
    echo("pong"),

// Neither new nor old code runs.
ping.unblock;
assert(!ping.blocked);
sleep(2.1s);

// But we can use the tag again.
ping:
  every (1s)
    echo("ping again"),
sleep(2.1s);
[00004000] *** ping again
[00005000] *** ping again
[00006000] *** ping again
\end{urbiscript}

As with \lstinline|stop|, one can force the value of stopped
expressions.

\begin{urbiscript}
assert(
  ["foo", "foo", "foo"]
  ==
  {
    var t = Tag.new;
    var res = [];
    for (3)
      detach(res << {t: sleep(inf)});
    t.block("foo");
    res;
  });
\end{urbiscript}

\subsubsection{Freeze/unfreeze}
\label{sec:specs:tag:freeze}

To \dfn{freeze} a tag means holding the execution of code it labels.
This applies to code already being run, and ``arriving'' pieces of code.

\begin{urbiscript}
var t = Tag.new|;
var t0 = time|;
t: every(1s) echo("time   : %.0f" % (time - t0)),
sleep(2.2s);
[00000158] *** time   : 0
[00001159] *** time   : 1
[00002159] *** time   : 2

t.freeze;
assert(t.frozen);
t: every(1s) echo("shifted: %.0f" % (shiftedTime - t0)),
sleep(2.2s);
// The tag is frozen, nothing is run.

// Unfreeze the tag: suspended code is resumed.
// Note the difference between "time" and "shiftedTime".
t.unfreeze;
assert(!t.frozen);
sleep(2.2s);
[00004559] *** shifted: 2
[00005361] *** time   : 5
[00005560] *** shifted: 3
[00006362] *** time   : 6
[00006562] *** shifted: 4
\end{urbiscript}


\subsubsection{Scope tags}
\label{sec:specs:tag:scope}

Scopes feature a \lstindex{scopeTag}, i.e., a tag which will be stop
when the execution reaches the end of the current scope.  This is
handy to implement cleanups, how ever the scope was exited from.

\begin{urbiscript}
{
  var t = scopeTag;
  t: every(1s)
      echo("foo"),
  sleep(2.2s);
};
[00006562] *** foo
[00006562] *** foo
[00006562] *** foo

{
  var t = scopeTag;
  t: every(1s)
      echo("bar"),
  sleep(2.2s);
  throw 42;
};
[00006562] *** bar
[00006562] *** bar
[00006562] *** bar
[00006562:error] !!! 42
sleep(2s);
\end{urbiscript}

\subsubsection{Enter/leave events}
\label{sec:specs:tag:enter-leave}

Tags provide two events, \lstinline|enter| and \lstinline|leave|, that
trigger whenever flow control enters or leaves statements they tag.

\begin{urbiscript}
var t = Tag.new("t");
[00000000] Tag<t>

at (t.enter?)
  echo("enter");
at (t.leave?)
  echo("leave");

t: {echo("inside"); 42};
[00000000] *** enter
[00000000] *** inside
[00000000] *** leave
[00000000] 42
\end{urbiscript}

This feature is fundamental, since it is a concise and safe way to
ensure code will be executed upon exiting a chunk of code (like
\acronym{raii} in \Cxx or \lstinline|finally| in Java). The exit code
will be run no matter what the reason for leaving the block was:
natural exit, exceptions, flow control instructions like
\lstinline|return| or \lstinline|break|, \ldots

For instance, suppose we want to make sure we turn the gas off when
we're done cooking. Here is the \emph{bad} way to do it:

\begin{urbiscript}
function cook()
{
  turn_gas_on();

  // Cooking code ...

  turn_gas_off();
}|

enter_the_kitchen();
cook();
leave_the_kitchen();
\end{urbiscript}

This is bad because there are several situation where we could leave
the kitchen with gas still turned on. Consider the following cooking
code:

\begin{urbiscript}
function cook()
{
  turn_gas_on();

  if (meal_ready)
  {
    echo("The meal is already there, nothing to do!");
    // Oops ...
    return
  };

  for (var ingredient in recipe)
    if (ingredient not in kitchen)
      // Oops ...
      throw Exception("missing ingredient: %s" % ingredient)
    else
      put_ingredient();

  // ...

  turn_gas_off();
}|

enter_the_kitchen();
cook();
leave_the_kitchen();
\end{urbiscript}

Here you can see that if the meal was already prepared, or that if an
ingredient is missing, we will leave the \lstinline|cook| function
without executing the \lstinline|turn_gas_off| statement, through the
\lstinline|return| statement or the exception. The right way to ensure
gas is necessarily turned off is:

\begin{urbiscript}
function cook()
{
  var with_gas = Tag.new("with_gas");

  at (with_gas.enter?)
    turn_gas_on();
  at (with_gas.leave?)
    turn_gas_off();

  with_gas: {
    // Cooking code. Even if exception are thrown here or return is called,
    // the gas will be turned off.
  }
}|

enter_the_kitchen();
cook();
leave_the_kitchen();
\end{urbiscript}

\subsubsection{Begin/end}
\label{sec:specs:tag:begin-end}

The \lstinline|begin| and \lstinline|end| methods enable you to
monitor when your code is executed. This is a good example of a good
use of enter and leave events (\autoref{sec:specs:tag:enter-leave}),
which are use in backend to implement this feature.

\begin{urbiscript}
var mytag = Tag.new("mytag");
[00000000] Tag<mytag>

mytag.begin: echo(1);
[00000000] *** mytag: begin
[00000000] *** 1

mytag.end: echo(2);
[00000000] *** 2
[00000000] *** mytag: end

mytag.begin.end: echo(3);
[00000000] *** mytag: begin
[00000000] *** 3
[00000000] *** mytag: end
\end{urbiscript}

\subsection{Slots}

\begin{itemize}
\item \lstinline|block(\var{result} = void)|~\\
  Block any code tagged by \lstinline|this|.  Blocked tags can be
  unblocked using \lstinline|Tag.unblock|.  If some \var{result} was
  specified, let stopped code return \var{result} as value.  See
  \autoref{sec:specs:tag:block}.

\item \lstinline|begin|~\\
  A subtag that prints out "tag\_name: begin" everytime flow control
  enters the tagged code. See \autoref{sec:specs:tag:begin-end}.

\item \lstinline|blocked|~\\
  Whether code tagged by \lstinline|this| is blocked.  See
  \autoref{sec:specs:tag:block}.

\item \lstinline|end|~\\
  A subtag that prints out "tag\_name: end" everytime flow control
  leaves the tagged code. See \autoref{sec:specs:tag:begin-end}.

\item \lstinline|enter|~\\
  An event that trigger everytime flow control enter the tagged code.
  See \autoref{sec:specs:tag:enter-leave}.

\item \lstinline|freeze|~\\
  Suspend code tagged by \lstinline|this|, already running or
  forthcoming.  Frozen code can be later unfrozen using
  \lstinline|Tag.unfreeze|.  See \autoref{sec:specs:tag:freeze}.

\item \lstinline|frozen|~\\
  Whether the tag is frozen. See  \autoref{sec:specs:tag:freeze}.

\item \lstinline|leave|~\\
  An event that trigger everytime flow control leaves the tagged code.
  See \autoref{sec:specs:tag:enter-leave}.

\item \lstinline|stop(\var{result} = void)|~\\
  Stop any code tagged by \lstinline|this|.  If some \var{result} was
  specified, let stopped code return \var{result} as value.
  See \autoref{sec:specs:tag:stop}.

\item \lstinline|unblock|~\\
  Unblock \lstinline|this|.  See \autoref{sec:specs:tag:block}.

\item \lstinline|unfreeze|~\\
  Unfreeze code tagged by \lstinline|this|.  See
  \autoref{sec:specs:tag:freeze}.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:
