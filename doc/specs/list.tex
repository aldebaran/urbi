\section{List}

\lstinline|List|s implement potentially-empty ordered (heterogeneous)
collections of elements.

\subsection{Prototypes}

\begin{itemize}
\item \refObject{Object}
\end{itemize}

\subsection{Construction}

List can be created with their literal syntax: a possibly empty
sequence of expressions in square brackets, separated by commas.
Non-empty list may actually \emph{terminate} with a comma, rather than
\emph{separate}; in other words, an optional trailing comma is accepted.

\begin{urbiscript}
[]; // The empty list
[00000000] []
[1, "2", [3,],];
[00000000] [1, "2", [3]]
\end{urbiscript}

\subsection{Methods}

\begin{itemize}
\item \lstinline|all(\var{fun})|\\
% FIXME: link to predicate glossary entry
Return whether all the members of the target verify the given
predicate.

\begin{urbiscript}[firstnumber=last]
// Are all elements positive?
assert(! [-2, 0, 2, 4].all(function (e) { e > 0 }));
// Are all elements even?
assert([-2, 0, 2, 4].all(function (e) { e % 2 == 0 }));
\end{urbiscript}

\item \lstinline|any(\var{fun})|\\
% FIXME: link to predicate glossary entry
Return whether at least one of the members of the target verify the
given predicate.

\begin{urbiscript}[firstnumber=last]
// Is there any even element?
assert(! [-3, 1, -1].any(function (e) { e % 2 == 0 }));
// Is there any positive element?
assert([-3, 1, -1].any(function (e) { e > 0 }));
\end{urbiscript}

\item \lstinline|asBool|\\
  Whether not empty.
\begin{urbiscript}[firstnumber=last]
assert([].asBool == false);
assert([1].asBool == true);
\end{urbiscript}

\item \lstinline|asList|\\
Return the target.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].asList == [0, 1, 2]);
\end{urbiscript}

\item \lstinline|asString|\\
Return the target as a string describing the list.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].asString == "[0, 1, 2]");
\end{urbiscript}

\item \lstinline|back|\\
Return the last element of the target. An error if the target is empty.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].back == 2);
[].back;
[00000000:error] !!! back: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|clear|\\
  Empty the target.

\begin{urbiscript}[firstnumber=last]
var x = [0, 1, 2];
[00000000] [0, 1, 2]
assert(x.clear == []);
\end{urbiscript}

\item \lstinline|each(\var{fun})|\\
Apply the given functional value on all members sequentially.

\begin{urbiscript}[firstnumber=last]
[0, 1, 2].each(function (v) {echo (v * v); echo (v * v)});
[00000000] *** 0
[00000000] *** 0
[00000000] *** 1
[00000000] *** 1
[00000000] *** 4
[00000000] *** 4
\end{urbiscript}

\item \lstinline|each&(\var{fun})|\\
Apply the given functional value on all members simultaneously.

\begin{urbiscript}[firstnumber=last]
[0, 1, 2].'each&'(function (v) {echo (v * v); echo (v * v)});
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
[00000000] *** 0
[00000000] *** 1
[00000000] *** 4
\end{urbiscript}

\item \lstinline|empty|\\
  Whether the target is empty.

\begin{urbiscript}[firstnumber=last]
assert([].empty);
assert(! [1].empty);
\end{urbiscript}

\item \lstinline|filter(\var{fun})|\\
  Return the list of all member of the target that verify the given
  predicate.

\begin{urbiscript}[firstnumber=last]
// Keep only odd numbers
assert([0, 1, 2, 3, 4, 5].filter(function (v) {v % 2 == 1}) == [1, 3, 5]);
\end{urbiscript}

\item \lstinline|foldl(\var{action}, \var{value})|\\
  \href{http://en.wikipedia.org/wiki/Fold_(higher-order_function)}{Fold},
  also known as \dfn{reduce} or \dfn{accumulate}, computes a result
  from a list.  Starting from \var{value} as the initial result, apply
  repeatedly the binary \var{action} to the current result and the
  next member of the list, from left to right.  For instance, if
  \var{action} were the binary addition and \var{value} were 0, then
  folding a list would compute the sum of the list, including for
  empty lists.

\begin{urbiscript}[firstnumber=last]
[].foldl(function (a, b) { a + b }, 0);
[00000000] 0
[1, 2, 3].foldl(function (a, b) { a + b }, 0);
[00000000] 6
[1, 2, 3].foldl(function (a, b) { a - b }, 0);
[00000000] -6
\end{urbiscript}

\item \lstinline|front|\\
  Return the first element of the target. An error if the target is
  empty.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].front == 0);
[].front;
[00000000:error] !!! front: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|has(\var{that})|\\
  Whether one of the members of the target equals the argument.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].has(1));
assert(! [0, 1, 2].has(5));
\end{urbiscript}

\item \lstinline|hasSame(\var{that})|\\
  Return whether one of the member of the target is physically equal
  to the argument.

\begin{urbiscript}[firstnumber=last]
var y = 1;
[00000000:hide] 1
[0, y, 2].hasSame(1);
[00000000] false
[0, y, 2].hasSame(y);
[00000000] true
\end{urbiscript}

\item \lstinline|head|\\
  Synonym for \lstinline|front|.

\item \lstinline|insertBack(\var{that})|\\
  Insert the given element at the end of the target.

\begin{urbiscript}[firstnumber=last]
var z = [0, 1];
[00000000] [0, 1]
assert(z.insertBack(2) == [0, 1, 2]);
assert(z == [0, 1, 2]);
\end{urbiscript}

\item \lstinline|insertFront(\var{that})|\\
  Insert the given element at the beginning of the target.

\begin{urbiscript}[firstnumber=last]
var a = [1, 2];
[00000000] [1, 2]
assert(a.insertFront(0) == [0, 1, 2]);
assert(a == [0, 1, 2]);
\end{urbiscript}

\item \lstinline|join(\var{sep})|\\
  Concatenate all members of the target to form a string, separating
  them with the given separator.

\begin{urbiscript}[firstnumber=last]
assert(["b", "ob", "b"].join("a") == "baobab");
\end{urbiscript}

\item \lstinline|map(\var{fun})|\\
Apply the given functional value on every member, and return the list
of results.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2, 3].map(function (v) { v % 2 == 0})
        == [true, false, true, false]);
\end{urbiscript}

\item \lstinline|range(\var{begin}, \var{end})|\\
  Return a sub-range of the string, from the first index included to
  the second index excluded. An error if out of bounds.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2, 3].range(1, 3) == [1, 2]);
[].range(1, 3);
[00428697:error] !!! urbi/list.u: []: invalid index: 1
\end{urbiscript}

\item \lstinline|remove(\var{val})|\\
  Remove all elements from the target that equals \var{val}.

\begin{urbiscript}[firstnumber=last]
var c = [0, 1, 0, 2, 0, 3];
[00000000] [0, 1, 0, 2, 0, 3]
assert(c.remove(0) == [1, 2, 3]);
assert(c == [1, 2, 3]);
\end{urbiscript}

\item \lstinline|removeBack|\\
  Remove and return the last element of the target. An error if the
  target is empty.

\begin{urbiscript}[firstnumber=last]
var t = [0, 1, 2];
[00000000] [0, 1, 2]
assert(t.removeBack == 2);
assert(t == [0, 1]);
[].removeBack;
[00000000:error] !!! removeBack: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|removeById(\var{that})|\\
  Remove all elements from the target that physically equals
  \var{that}.

\begin{urbiscript}[firstnumber=last]
var d = 1;
[00000000] 1
var e = [0, 1, d, 1, 2];
[00000000] [0, 1, 1, 1, 2]
assert(e.removeById(d) == [0, 1, 1, 2]);
assert(e == [0, 1, 1, 2]);
\end{urbiscript}

\item \lstinline|removeFront|\\
Remove and return the first element from the target. An error if the
target is empty.

\begin{urbiscript}[firstnumber=last]
var g = [0, 1, 2];
[00000000] [0, 1, 2]
assert(g.removeFront == 0);
assert(g == [1, 2]);
[].removeFront;
[00000000:error] !!! removeFront: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|reverse|\\
Return the target with the order of elements inverted.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].reverse == [2, 1, 0]);
\end{urbiscript}

\item \lstinline|size|\\
Return the number of elements in the target.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].size == 3);
assert([].size == 0);
\end{urbiscript}

\item \lstinline|sort|\\
Return the target, sorted with respect to the \lstinline|<| criteria.

\begin{urbiscript}[firstnumber=last]
assert([1, 0, 3, 2].sort == [0, 1, 2, 3]);
\end{urbiscript}

\item \lstinline|tail|\\
Return the target, minus the first element. An error if the target is
empty.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2].tail == [1, 2]);
[].tail;
[00000000:error] !!! tail: cannot be applied onto empty list
\end{urbiscript}

\item \lstinline|'=='(\var{that})|\\
Check whether all elements in the target and \var{that}, are
equal two by two.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 2] == [0, 1, 2]);
assert(!([0, 1, 2] == [0, 0, 2]));
\end{urbiscript}

\item \lstinline|'[]'(\var{n})|\\
  Return the nth member of the target (indexing is zero-based). An
  error if out of bounds.

\begin{urbiscript}[firstnumber=last]
var l = [0, 1, 2];
[00000000:hide] [0, 1, 2]
l[1];
[00000000] 1
l[3];
[00007061:error] !!! []: invalid index: 3
\end{urbiscript}

\item \lstinline|'[]='(\var{index}, \var{value})|\\
  Assign \var{value} to the element of the target at the given
  \var{index}.

\begin{urbiscript}[firstnumber=last]
var f = [0, 1, 2];
[00000000] [0, 1, 2]
f[1] = 42;
[00000000] 42
assert(f == [0, 42, 2]);
\end{urbiscript}

\item \lstinline|'*'(\var{times})|\\
Return the target, concatenated n times to itself, n being \var{times}.

\begin{urbiscript}[firstnumber=last]
assert([0, 1] * 3 == [0, 1, 0, 1, 0, 1]);
\end{urbiscript}

\item \lstinline|'+'(\var{other})|\\
Return the concatenation of the target and the \var{other} list.

\begin{urbiscript}[firstnumber=last]
assert([0, 1] + [2, 3] == [0, 1, 2, 3]);
\end{urbiscript}

\item \lstinline|'-'(\var{other})|\\
Return the target without all element that equals any element in the
\var(other) list.

\begin{urbiscript}[firstnumber=last]
assert([0, 1, 0, 2, 3] - [1, 2] == [0, 0, 3]);
\end{urbiscript}

\item \lstinline|'<<'(\var{that})|\\
  A synonym for \lstinline|insertBack|.

\item \lstinline|'<'(\var{other})|\\
  Return whether the target is inferior to the \var{other} list. A
  list is inferior to another if at least one of its element differs
  from the other, and the first differing element is inferior to the
  other.

\begin{urbiscript}[firstnumber=last]
assert(!([0, 1, 2] < [0, 1, 2]));
assert(!([0, 1, 2] < [0, 0, 2]));
assert([0, 1, 2] < [0, 2, 2]);
\end{urbiscript}

\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:

% LocalWords:  lst asList asString foldl hasSame removeBack popback removeFront
% LocalWords:  popfront insertBack pushback insertFront pushfront urbi sameAs
% LocalWords:  removeById setNth
