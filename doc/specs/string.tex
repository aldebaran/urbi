\section{String}

A \dfn{string} is a sequence of characters.

\subsection{Prototypes}
\begin{itemize}
\item \refObject{Comparable}
\item \refObject{Orderable}
\item \refObject{RangeIterable}
\end{itemize}

\subsection{Construction}
Fresh Strings can easily be built using the literal syntax.  Several
escaping sequences (the traditional ones and \us specific ones) allow
to insert special characters.  Consecutive string literals are merged
together.  See \autoref{sec:us-syn-lit-string} for details and
examples.

A null String can also be obtained with \lstinline|String|'s
\lstinline|new| method.

\begin{urbiscript}
assert(String.new == "");
assert(String == "");
assert("123".new == "123");
\end{urbiscript}

\subsection{Methods}
\begin{itemize}
\item \lstinline|asFloat|\\
  If the whole content of \lstinline|this| is an integer, return its
  value, otherwise return an error.
\begin{urbiscript}[firstnumber=last]
assert("23.03".asFloat == 23.03);

"123abc".asFloat;
[00000001:error] !!! asFloat: unable to convert to float: "123abc"
\end{urbiscript}

\item \lstinline|asList|\\
  Return a List of one-letter Strings that, concataneted, equal
  \lstinline|this|.  This allows to use \lstinline|for| to iterate
  over the string.
\begin{urbiscript}[firstnumber=last]
assert("123".asList == ["1", "2", "3"]);
for (var v : "123")
  echo(v);
[00000001] *** 1
[00000001] *** 2
[00000001] *** 3
\end{urbiscript}

\item \lstinline|asPrintable|\\
  Return \lstinline|this| as a literal (escaped) string.
\begin{urbiscript}[firstnumber=last]
assert("foo".asPrintable == "\"foo\"");
assert("foo".asPrintable.asPrintable == "\"\\\"foo\\\"\"");
\end{urbiscript}

\item \lstinline|asString|\\
  Return \lstinline|this|.
\begin{urbiscript}[firstnumber=last]
assert("\"foo\"".asString == "\"foo\"");
\end{urbiscript}

\item \lstinline|distance(\var{other})|\\
  Return the
  \href{http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance}
  {Damerau-Levenshtein distance} between \lstinline|this| and
  \var{other}.  The more alike the strings are, the smaller the
  distance is.
\begin{urbiscript}[firstnumber=last]
assert("foo".distance("foo") == 0);
assert("bar".distance("baz") == 1);
assert("foo".distance("bar") == 3);
\end{urbiscript}

\item \lstinline|fresh|\\
  Return a String that has never been used as an identifier, prefixed
  by \lstinline|this|.  It can safely be used with
  \lstinline|Object.setSlot| and so forth.
\begin{urbiscript}[firstnumber=last]
assert(String.fresh == "_5");
assert("foo".fresh == "foo_6");
\end{urbiscript}

\item Character handling functions\\
  Here is a map of how the original 127-character ASCII set is
  considered by each function (a \textbullet{} indicates that the function
  returns true if all characters of \lstinline|this| are on the
  row).

\begin{tabular}{|l||l||c|c|c|c|c|c|c|c|c|c|c|}
  \hline
  &&&&&&&&&&&&\\
  ASCII values & Characters & \begin{sideways}iscntrl\end{sideways}
    & \begin{sideways}isspace\end{sideways}
    & \begin{sideways}isupper\end{sideways}
    & \begin{sideways}islower\end{sideways}
    & \begin{sideways}isalpha\end{sideways}
    & \begin{sideways}isdigit\end{sideways}
    & \begin{sideways}isxdigit\end{sideways}
    & \begin{sideways}isalnum\end{sideways}
    & \begin{sideways}ispunct\end{sideways}
    & \begin{sideways}isgraph\end{sideways}
    & \begin{sideways}print \end{sideways}\\ \hline \hline
  0x00 .. 0x08 & & \textbullet & & & & & & & & & &\\ \hline
  0x09 .. 0x0D & \textbackslash{}t, \textbackslash{}f,
  \textbackslash{}v, \textbackslash{}n, \textbackslash{}r &
  \textbullet & \textbullet & & & & & & & & &\\ \hline
  0x0E .. 0x1F & & \textbullet & & & & & & & & & &\\ \hline
  0x20 & space (' ') & & \textbullet & & & & & & & & & \textbullet\\ \hline
  0x21 .. 0x2F & \verb|!"#$%&'()*+,-./| & & & & & & & & & \textbullet & \textbullet & \textbullet\\ \hline
  0x30 .. 0x39 & \verb|0-9| & & & & & & \textbullet & \textbullet & \textbullet & & \textbullet & \textbullet\\ \hline
  0x3a .. 0x40 & \verb|:;<=>?@| & & & & & & & & & \textbullet & \textbullet & \textbullet\\ \hline
  0x41 .. 0x46 & \verb|A-F| & & & \textbullet & & \textbullet & & \textbullet & \textbullet & & \textbullet & \textbullet\\ \hline
  0x47 .. 0x5A & \verb|G-Z| & & & \textbullet & & \textbullet & & & \textbullet & & \textbullet & \textbullet\\ \hline
  0x5B .. 0x60 & \verb|[\]^{}_`| & & & & & & & & & \textbullet & \textbullet & \textbullet\\ \hline
  0x61 .. 0x66 & \verb|a-f| & & & & \textbullet & \textbullet & & \textbullet & \textbullet & & \textbullet & \textbullet\\ \hline
  0x67 .. 0x7A & \verb|g-z| & & & & \textbullet & \textbullet & & & \textbullet & & \textbullet & \textbullet\\ \hline
  0x7B .. 0x7E & \verb-{|}~- & & & & & & & & & \textbullet & \textbullet & \textbullet\\ \hline
  0x7F & (DEL) &  \textbullet & & & & & & & & & &\\
  \hline
\end{tabular}

\begin{urbiscript}[firstnumber=last]
assert("".isDigit);
assert("0123456789".isDigit);
assert(!"a".isDigit);

assert("".isLower);
assert("lower".isLower);
assert(! "Not Lower".isLower);

assert("".isUpper);
assert("UPPER".isUpper);
assert(! "Not Upper".isUpper);
\end{urbiscript}

\item \lstinline|join(\var{list}, \var{prefix}, \var{suffix})|\\
  Glue the result of \lstinline|asString| applied to the members of
  \var{list}, separated by \lstinline|this|, and embedded in a pair
  \var{prefix}/var{suffix}.
\begin{urbiscript}[firstnumber=last]
assert("|".join([1, 2, 3], "(", ")")      == "(1|2|3)");
assert(", ".join([1, [2], "3"], "[", "]") == "[1, [2], 3]");
\end{urbiscript}

\item \lstinline|replace(\var{from}, \var{to})|\\
  Replace every occurrence of the string \var{from} in
  \lstinline|this| by \var{to}, and return the result.
  \lstinline|this| is not modified.
\begin{urbiscript}[firstnumber=last]
assert("Hello, World!".replace("Hello", "Bonjour")
                      .replace("World!", "Monde !") ==
       "Bonjour, Monde !");
\end{urbiscript}

\item \lstinline|size|\\
  Return the size of the string.
\begin{urbiscript}[firstnumber=last]
assert("foo".size == 3);
assert("".size == 0);
\end{urbiscript}

\item \lstinline|toLower|\\
  Make lower case every upper case character in \lstinline|this| and
  return the result.  \lstinline|this| is not modified.
\begin{urbiscript}[firstnumber=last]
assert("Hello == World!".toLower, "hello, world!");
\end{urbiscript}

\item \lstinline|toUpper|\\
  Make upper case every lower case character in \lstinline|this| and
  return the result.  \lstinline|this| is not modified.
\begin{urbiscript}[firstnumber=last]
assert("Hello == World!".toUpper, "HELLO, WORLD!");
\end{urbiscript}

\item \lstinline|'%'(\var{args})|\\
  It is an equivalent of \lstinline|Formatter.new(this) % \var{args}|.
  See \refObject{Formatter}.
%  This construct is actually more
%  powerful than this, since it relies on
%  \href{http://www.boost.org/doc/libs/1_39_0/libs/format/doc/format.html,
%    Boost.Format}.  For instance:
\begin{urbiscript}[firstnumber=last]
assert("%s + %s = %s" % [1, 2, 3] == "1 + 2 = 3");
\end{urbiscript}

\item \lstinline|'*'(\var{n})|\\
  Concatenate \lstinline|this| \var{n} times.
\begin{urbiscript}[firstnumber=last]
assert("foo" * 0 == "");
assert("foo" * 1 == "foo");
assert("foo" * 3 == "foofoofoo");
\end{urbiscript}

\item \lstinline|'+'(\var{other})|\\
  Concatenate \lstinline|this| and \lstinline|\var{other}.asString|.
\begin{urbiscript}[firstnumber=last]
assert("foo" + "bar" == "foobar");
assert("foo" + "" == "foo");
assert("foo" + 3 == "foo3");
assert("foo" + [1, 2, 3] == "foo[1, 2, 3]");
\end{urbiscript}

\item \lstinline|'<'(\var{other})|\\
  Whether \lstinline|this| is lexicographically before \var{other},
  which must be a String.
\begin{urbiscript}[firstnumber=last]
assert("" < "a");
assert(!("a" < ""));
assert("a" < "b");
assert(!("a" < "a"));
\end{urbiscript}

\item \lstinline|'[]'(\var{from})|\\
  \lstinline|'[]'(\var{from}, \var{to})|\\
  Return the substring starting at \var{from}, up to and not including
  \var{to} (which defaults to \var{to} + 1).
\begin{urbiscript}[firstnumber=last]
assert("foobar"[0, 3] == "foo");
assert("foobar"[0] == "f");
\end{urbiscript}

\item \lstinline|'[]='(\var{from}, \var{other})|\\
  \lstinline|'[]='(\var{from}, \var{to}, \var{other})|\\
  Replace the substring starting at \var{from}, up to and not including
  \var{to} (which defaults to \var{to} + 1), by \var{other}.  Return
  \var{other}.

  Beware that this routine is imperative: it changes the value of
  \lstinline|this|.
\begin{urbiscript}[firstnumber=last]
var s1 = "foobar" | var s2 = s1 |
assert((s1[0, 3] = "quux") == "quux");
assert(s1 == "quuxbar");
assert(s2 == "quuxbar");
assert((s1[4, 7] = "") == "");
assert(s2 == "quux");
\end{urbiscript}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../urbi-sdk"
%%% End:
