@techreport{olson.06.tr,
  title =        {Introduction to Concurrent Programming with
                  {Stackless} {Python}},
  author =       {Grant Olson},
  year =         2006,
  month =        {July},
  url =
                  {http://members.verizon.net/olsongt/stackless/why_stackless.pdf},
  note =         {A tutorial on Stackless.  Interesting to read, not
                  scientific.},
}

@inproceedings{rigo.04.pepm,
  author =       {Armin Rigo},
  title =        {Representation-based just-in-time specialization and
                  the {Psyco} prototype for {Python}},
  booktitle =    {PEPM'04: Proceedings of the 2004 ACM SIGPLAN
                  symposium on Partial evaluation and semantics-based
                  program manipulation},
  year =         {2004},
  isbn =         {1-58113-835-0},
  pages =        {15--26},
  location =     {Verona, Italy},
  doi =          {http://doi.acm.org/10.1145/1014007.1014010},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  abstract =     {A powerful application of specialization is to
                  remove interpretative overhead: a language can be
                  implemented with an interpreter, whose performance
                  is then improved by specializing it for a given
                  program source. This approach is only moderately
                  successful with very dynamic languages, where the
                  outcome of each single step can be highly dependent
                  on run-time data. We introduce in the present paper
                  two novel specialization techniques and discuss in
                  particular their potential to close the performance
                  gap between dynamic and static languages:
                  Just-in-time specialization, or specialization by
                  need, introduces the ``unlifting'' ability for a
                  value to be promoted from run-time to compile-time
                  during specialization --- the converse of the lift
                  operator of partial evaluation. Its presence gives
                  an unusual and powerful perspective on the
                  specialization process.  Representations are a
                  generalization of the traditional specialization
                  domains, i.e.  the compile-time/run-time dichotomy
                  (also called static/dynamic, or ``variables known at
                  specialization time''/``variables only known at run
                  time''). They provide a theory of data
                  specialization.  These two techniques together shift
                  some traditional problems and limitations of
                  specialization. We present the prototype Psyco for
                  the Python language. },
}

@inproceedings{rigo.06.oopsla,
  author =       {Armin Rigo and Samuele Pedroni},
  title =        {{PyPy}'s approach to virtual machine construction},
  booktitle =    {OOPSLA'06: Companion to the 21st ACM SIGPLAN
                  symposium on Object-oriented programming systems,
                  languages, and applications},
  year =         {2006},
  isbn =         {1-59593-491-X},
  pages =        {944--953},
  location =     {Portland, Oregon, USA},
  doi =          {http://doi.acm.org/10.1145/1176617.1176753},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  url =
                  {http://codespeak.net/svn/pypy/extradoc/talk/dls2006/pypy-vm-construction.pdf},
}

@techreport{rossum.95.tr,
  author =       {Guido van Rossum},
  title =        {Python tutorial},
  year =         {1995},
  source =
                  {http://www.ncstrl.org:8900/ncstrl/servlet/search?formname=detail\&id=oai%3Ancstrlh%3Aercim_cwi%3Aercim.cwi%2F%2FCS-R9526},
  institution =  {CWI (Centre for Mathematics and Computer Science)},
  publisher =    {CWI (Centre for Mathematics and Computer Science)},
  address =      {Amsterdam, The Netherlands, The Netherlands},
  abstract =     {Python is a simple, yet powerful programming
                  language that bridges the gap between C and shell
                  programming, and is thus ideally suited for
                  ``throw-away programming'' and rapid
                  prototyping. Its syntax is put together from
                  constructs borrowed from a variety of other
                  languages; most prominent are influences from ABC,
                  C, Modula-3 and Icon. The Python interpreter is
                  easily extended with new functions and data types
                  implemented in C. Python is also suitable as an
                  extension language for highly customizable C
                  applications such as editors or window
                  managers. Python is available for various operating
                  systems, amongst which several flavors of UNIX,
                  Amoeba, the Apple Macintosh O.S., and MS-DOS. This
                  tutorial introduces the reader informally to the
                  basic concepts and features of the Python language
                  and system. It helps to have a Python interpreter
                  handy for hands-on experience, but as the examples
                  are self-contained, the tutorial can be read
                  off-line as well. For a description of standard
                  objects and modules, see the Python Library
                  Reference manual. The Python Reference Manual gives
                  a more formal definition of the language.}
}

@techreport{tismer.00.tr,
  title =        {Continuations and {Stackless} {Python} Or ``How to
                  change a Paradigm of an existing Program''},
  author =       {Christian Tismer},
  year =         2000,
  institution =  {Virtual Photonics GmbH},
  abstract =     {In this paper, an implementation of ``Stackless
                  Python'' (a Python which does not keep state on the
                  C stack) is presented. Surprisingly, the necessary
                  changes affect just a small number of C modules, and
                  a major rewrite of the C library can be avoided. The
                  key idea in this approach is a paradigm change for
                  the Python code interpreter that is not easy to
                  understand in the first place. Recursive interpreter
                  calls are turned into tail recursion, which allows
                  deferring evaluation by pushing frames to the frame
                  stack, without the C stack involved.  By decoupling
                  the frame stack from the C stack, we now have the
                  ability to keep references to frames and to do
                  non-local jumps. This turns the frame stack into a
                  tree, and every leaf of the tree can now be a jump
                  target. While exploring this idea, we will recognize
                  ordinary function calls and returns to be just
                  special cases of so-called continuations, and we
                  will learn about them as a really simple idea that
                  covers all kinds of program flow.  Instead of an
                  implementation of coroutines and generators as C
                  extensions, we will see how they can be expressed in
                  Python, using the continuation module. Since the
                  theory of continuations is not very broadly known, a
                  small introduction is given.  },
}

@Misc{tismer.08.www,
  author =	 {Christian Tismer},
  title =	 {{Stackless} {Python}},
  howpublished = {\url{http://www.stackless.com}}
}