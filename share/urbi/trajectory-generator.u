class Global.TrajectoryGenerator
{
  /// Stop adaptive trajectory if error is below this value.
  var delta = 2;
  function getStartValue()
  {
    var this.startValue = getter() |
    if (startValue.type == "Float")
      this.startValue = startValue
    else if (startValue.type == "Group")
    {
      var v = startValue.members.head |
      while (v.type == "List")
	v = v.head |
      this.startValue = v
    }
    else
    {
      this.startValue = 0|
      "Warning: setting dummy startValue".print
    }
  };
  function init(getter, setter, targetValue, args)
  {
    var this.getter = getter |
    var this.setter = setter |
    this.targetValue = targetValue|
    this.startTime = time|
    if ("time" in args)
    {
      getStartValue()|
      var this.adaptive = args.getWithDefault("adaptive", 0) |
      if (this.adaptive)
	var this.get = getSlot("timeAdaptiveGet")
      else
	var this.get = getSlot("timeGet") |
      var this.duration = args.get("time") |
    }
    else if ("smooth" in args)
    {
      getStartValue()|
      var this.adaptive = args.getWithDefault("adaptive", 0) |
      var this.get = getSlot("smoothGet") |
      var this.duration = args.get("smooth") |
    }
    else if ("accel" in args)
    {
      getStartValue()|
      var this.get = getSlot("accelGet") |
      var this.accel = args.get("accel") / 1000000 |
      var this.duration = sqrt ( 2 * (targetValue - this.startValue) / accel)
    }
    else if ("speed" in args)
    {
      getStartValue()|
      var this.adaptive = args.getWithDefault("adaptive", 0) |
      var this.speed = args.get("speed") / 1000|
      var this.duration = Float.inf;
      if (speed != 0)
        this.duration = abs(this.startValue - targetValue)  / speed |
      if (adaptive)
        var this.get = getSlot("adaptiveSpeedGet")
      else
        var this.get = getSlot("timeGet") |
    }
    else if ("sin" in args || "cos" in args)
    {
      var this.get = getSlot("sinGet");
      var this.phase = args.getWithDefault("phase", 0) |
      var this.ampli = args.getWithDefault("ampli", 0) |
      if ("cos" in args)
      {
	var this.period =  args.get("cos") |
	this.phase += pi/2
      }
      else
	var this.period = args.get("sin")
    }
  };

  // Update the variable according to the trajectory.
  // Use the functions getter/setter to read/update the variable.
  // Blocking until the trajectory is over.
  function run()
  {
    var tag = Tag.new|
    tag:
    {
      every(getPeriod)
      {
	if (isOver)
          tag.stop|
	setter(get(getter)) |
      }|
      sleep(inf)
    }|
  };

  var startValue = 0;
  var startTime;
  var targetValue;
  var isOver = false;

  // Override system time to take shift induced by freeze into account.
  function time()
  {
    System.time - currentRunner.timeShift
  };

  function timeGet(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue + (targetValue - startValue) * stat
  };

  function smoothGet(currentVal)
  {
    var stat =  (time - startTime) / duration |
    if (stat > 1)
    {
      isOver = true|
      return targetValue
    } |
    startValue +
      (targetValue - startValue) * ( sin ( - pi / 2.0 + pi * stat) +1) / 2.0
  };

  function timeAdaptiveGet(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
    {
      isOver = true |
      return targetValue
    } |
    var stat = getPeriod / ( startTime + duration - time) |
    if (stat > 1 || stat < 0)
      return targetValue |
    currentVal + stat *  (targetValue - currentVal)
  };

  function sinGet
  {
    targetValue + ampli * sin( (time - startTime) * 2 * pi / period + phase)
  };

  function accelGet(currentVal)
  {
    if (time - startTime > duration)
    {
      isOver = true |
      return targetValue
    } |
    var d = (time - startTime) |
    d * d * 0.5 * accel
  };

  function adaptiveSpeedGet(currentVal)
  {
    if (abs(currentVal - targetValue) < delta)
    {
      isOver = true |
      return targetValue
    } |
    var nextVal = currentVal
      + speed * sgn(targetValue - currentVal) * getPeriod |
    if ((currentVal < targetValue && targetValue < nextVal)
      || (nextVal < targetValue && targetValue < currentVal))
    {
      nextVal = targetValue
    } |
    nextVal
  };
};
