/*-----------------.
| System version.  |
`-----------------*/

var System.version="2.0";

/*------------.
| Constants.  |
`------------*/

class Global.Constants
{
  var pi     = 3.14159265358979323846264338327950288;
  var inf    = Float.inf;
  var nan    = Float.nan;
};

Global.addProto (Global.Constants);

/*------.
| Tag.  |
`------*/

Global.addProto (Global.Tag);

/*---------.
| Object.  |
`---------*/

do Object
{
  // Cannot use "from" which is a k1 reserved word.
  function copySlot (frm, to)
  {
    setSlot(to, getSlot(frm))
  };

  function cloneSlot (frm, to)
  {
    setSlot(to, getSlot(frm).clone)
  };

  // Some sort of k1 compatibility.
  copySlot ("addProto", "inherit");
  copySlot ("removeProto", "disinherit");

  // Change the whole set of parents.
  function setProtos(ps)
  {
    // Beware that we may be losing the ancestry on Object, which has
    // access to "addProto".
    var add = Object.getSlot("addProto") |
    protos.clear() |
    for| (var p: ps.reverse)
      add.apply([this, p]) |
  };

  // Syntactic sugar for setProtos.
  protos->updateHook = function(slot, value) { setProtos(value); };

  function '==' (other)
  {
    sameAs(other)
  };

  function '===' (other)
  {
    memSameAs(other)
  };

  function hasSlot(name)
  {
    !locateSlot(name).isNil
  };

  function '!==' (rhs)
  {
    !(this === rhs)
  };

  // Invoke "clone", then "init".
  function 'new'
  {
    // The fresh child.
    var res = call.getSlot("target").clone |
    // Call the "init" from the parent, retargetted to the child.
    call.message = "init" |
    res.callMessage(call) |
    res
  };
};

/*---------.
| Global.  |
`---------*/

do Global
{
  // Import the primitives.
  addProto(System);

  // Look for file and load file.
  function load (file)
  {
    loadFile(searchFile(file));
  };

  // Assertion control
  var System.ndebug = false;
  function System.assert {
    if (!System.ndebug)
      System.assert_ (call.evalArgAt (1), call.argString (1));
  };

  function noop () {};
};

/*---------------.
| Call message.  |
`---------------*/

class Global.CallMessage
{
  function argString(i)
  {
    args.nth(i).string
  };

  function evalArgAt(i)
  {
    args.nth(i).eval
  };

  function argAt(i)
  {
    args.nth(i).value
  };

  function evalArgs()
  {
    args.tail.map(function (arg) { arg.eval })
  };

  function argsCount
  {
    args.size
  };
};

/*-------.
| Lazy.  |
`-------*/

load("urbi/lazy.u");

/*-------.
| List.  |
`-------*/

load("urbi/list.u");

/*------------.
| Singleton.  |
`------------*/

load("urbi/singleton.u");

/*-------.
| void.  |
`-------*/

// FIXME: Can't do this in urbi
// void.addProto(Singleton);

do Object
{
  var isVoid = false;
  function acceptVoid ()
  {
    this
  };
  function unAcceptVoid()
  {
    this
  }
};
var void.acceptVoid.acceptVoid = function() { new };
var void.acceptVoid.unAcceptVoid = function() { protos.front };

/*-----------.
| Booleans.  |
`-----------*/

load("urbi/boolean.u");

/*------.
| nil.  |
`------*/

do nil
{
  // Singleton derives from Object.
  setProtos([Singleton]);
  function '==' (x) { x.isNil };
  var asString = "nil";
  // nil prints nothing in the toplevel
  var asToplevelPrintable = nil;
};

do Object
{
  function isNil()
  {
    nil === this
  }
};

/*-------------------------.
| Method function wrappers |
`-------------------------*/

do Global
{
  // Make a function f from a method m, so as f(a, b, c) is equivalent
  // to a.m(b, c)
  // FIXME: I'm not satisfied with the name, but can't find anything
  // better
  function methodToFunction(name)
  {
    function
    {
      var args = call.evalArgs |
      var val = args.head.getSlot(name) |
      if (val.isA(Executable))
        return val.apply(args)
      else
        return val |
    }
  };
};

/*---------------------.
| Task related stuff.  |
`---------------------*/

// Detach takes an expression and evaluates it in background within
// the caller's context.
do Object
{
  function detach
  {
    var outer_call = call |
    spawn (function () { outer_call.evalArgAt (1) })
  };

  function detach_linked
  {
    var outer_call = call |
    spawn (function () { outer_call.evalArgAt (1) }, true)
  };

  // every_ takes two arguments, a delay and an expression.
  function every_
  {
    detach ({
      var delay = call.evalArgAt (1) |
      var deadline = shiftedTime |
      loop {
        detach (call.evalArgAt (2)) |
	deadline += delay |
        sleep (deadline - shiftedTime)
      }
    })
  };

  // at_ takes three expressions, a test and a code to execute each time the test
  // becomes true and a code to execute each time the test becomes false.
  function at_
  {
    registerAtJob(call.args.nth(1), call.args.nth(2), call.args.nth(3))
  };

  // whenever_ takes three expressions, a test and a code to execute each time the
  // test is true and a code to execute each time the test then becomes false.
  function whenever_
  {
    detach ({
      loop {
        waituntil (call.evalArgAt (1)) |
        loop {
          call.evalArgAt (2) |
          if (!call.evalArgAt (1))
            break
        };
        call.evalArgAt (3)
      }
    })
  };

  // waituntil takes an expression and waits until it becomes true.
  function waituntil {
    var t = currentRunner |
    t.setSideEffectFree (true) |
    while (!call.evalArgAt (1)) {
      t.waitForChanges
    } |
    t.setSideEffectFree (false)
  };

  // persist takes an expression and a delay, and returns an object
  // whose val slot evaluates to true if the expression has been
  // continously true for this delay and false otherwise.
  //
  // This function is used to implement
  //   at (condition ~ delay) action [onleave leaveaction]
  // as
  //   var u = persist (condition, delay);
  //   at (u.val) action [onleave leaveaction]
  //
  // The "persist" action will be controlled by the same tags as
  // the initial "at" block.
  function persist
  {
    var res = false |
    var tag = Tag.new("persist".fresh) |
    var delay = call.evalArgAt (2) |
    at_ (call.evalArgAt (1), detach({tag: { sleep (delay) | res = true }}),
         detach({ res = false | tag.stop })) |
    function () { res }
  };
};

load("urbi/channel.u");

// Disable top-level display
topLevel.enabled = false;
/*-------------.
| Comparable.  |
`-------------*/

class Global.Comparable
{
  function '!=' (rhs) { ! (this == rhs) };
  function '==' (rhs) { ! (this != rhs) };
};
// Provide !=.
Object.addProto(Comparable);

/*------------.
| Orderable.  |
`------------*/

class Global.Orderable
{
  function '<'  (rhs) { rhs > this };
  function '<=' (rhs) { this < rhs || this == rhs };
  function '>'  (rhs) { rhs < this };
  function '>=' (rhs) { this > rhs || this == rhs };
};


/*--------.
| Float.  |
`--------*/

load("urbi/updatehook-stack.u");
load("urbi/float.u");

load("urbi/trajectory-generator.u");

/*---------.
| String.  |
`---------*/
load("urbi/string.u");



/*-----------.
| Printing.  |
`-----------*/

do Object
{
  function isProto ()
  {
    locateSlot("protoName") === this
  };

  function type ()
  {
    if (isProto)
      "<" + protoName + ">"
    else
      protoName
  };

  // Gives type, + uid if relevant
  function id ()
  {
    var res = type.clone |
    if (!isProto)
      res += "_" + uid |
    res
  };

  // Destined to be overridden by subclasses.
  function asString ()
  {
    id
  };

  function asPrintable ()
  {
    asString
  };

  function asToplevelPrintable ()
  {
    asPrintable
  };
};

do Object
{
  function bounce_named (fn)
  {
    function (x) {
      x.getSlot (fn) .apply ([x])
    }
  };

  function bounce
  {
    bounce_named (call.argString (1))
  };
};

do Object
{
  var tasks = [];

  function eachBg(f, list)
  {
    if (list.size)
    {
      Object.tasks += [detach (f (list.head))];
      eachBg (f, list.tail)
    };
  };
};

load("urbi/k1.u");

/*--------------.
| Conversions.  |
`--------------*/

do Object
{
  function as(type)
  {
    getSlot("as" + type.protoName).apply([this])
  }
};

/*-------.
| Math.  |
`-------*/

class Global.Math
{
  for (var fn: ["abs", "acos", "asin", "atan", "cos", "exp", "log", "random",
               "round", "sgn", "sin", "sqr", "sqrt", "tan", "trunc"])
  {
    setSlot (fn, bounce_named (fn))
  };

  // Global variables
  var epsilontilde = 0.0001;
  var epsilonpercent = 0.0001;
};
Global.addProto (Global.Math);


/*---------.
| Groups.  |
`---------*/
load("urbi/group.u");

load("urbi/binary.u");

/*-----------------------.
| Profiling operations.  |
`-----------------------*/

class Global.Profiling
{
  function timen {
    var niters = call.evalArgAt (2);
    var start_time = time;
    var start_cycle = cycle |
    { for (var i = 0; i < niters; i++)
        call.evalArgAt (1)
    } |
    var ncycles = cycle - start_cycle - 1;
    var expired = time - start_time;
    echo ("Profiling information");
    echo ("  Expression:       " + call.argString (1));
    echo ("  Iterations:       " + niters);
    echo ("  Cycles:           " + ncycles);
    echo ("  Total time:       " + expired + " ms");
    echo ("  Single iteration: " + expired / niters + " ms");
    echo ("                    " + ncycles / niters + " cycles");
  };
};
Global.addProto (Global.Profiling);

/*-------------.
| Executable.  |
`-------------*/

// This class is used as a flag to recognize all kind of executable code
class Global.Executable {};

// Executable derives from Object.
for (var c: [Code, Primitive, Delegate])
  c.setProtos([Executable]);

load("urbi/loadable.u");

/*--------.
| Tuple.  |
`--------*/

load("urbi/tuple.u");

/*-------------.
| Dictionary.  |
`-------------*/

load("urbi/dictionary.u");

/*--------------------.
| Debugging helpers.  |
`--------------------*/

load("urbi/debug.u");

/*-------------------.
| Pattern matching.  |
`-------------------*/

load("urbi/pattern.u");

/*----------.
| UObject.  |
`----------*/

"Initializing uobjects NOW";
load("urbi/uobject.u");

// This variable is used by initialization code to detect the end of urbi.u.
topLevel.enabled = true |
var Object.loaded = 1 |
{};

// Make the tutorial available.
load("urbi/help.u");
// Load URBI.INI outside initialization phase.
"Loading URBI.INI";
load("URBI.INI");

/*-----------------------------------------------------------.
| Ready to go.  This string is special and expected by       |
|  uconsole-check as the signal that we have loaded urbi.u.  |
|  Messages before, and including this one, are ignored.     |
`-----------------------------------------------------------*/
"Urbi is up and running.";
