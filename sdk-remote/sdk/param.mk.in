# Don't set prefix, umake does.
PACKAGE_BRAND = @PACKAGE_BRAND@
URBI_ENV = $(UMAKE_URBI_ENV)
URBI_HOST = @URBI_HOST@
branddir = @branddir@
hostdir = @hostdir@
envdir = @hostdir@/$(URBI_ENV)
builddir = $(UMAKE_BUILD_DIR)
SHLIBEXT = @SHLIBEXT@

# The basename (no extension) of the library we should link against.
# This default value is for backward compatibility: find the
# (hopefully) unique lib here.
LIBNAME = $(UMAKE_LIBNAME)

# SDK flags.
SDK_CFLAGS = @SDK_CFLAGS@
SDK_CXXFLAGS = @SDK_CXXFLAGS@ @BOOST_CPPFLAGS@
SDK_LDFLAGS = @SDK_LDFLAGS@
SDK_LIBS = @SDK_LIBS@

# CPP.
CPP = @CPP@
URBI_KERNEL_PATH = @URBI_KERNEL_PATH@

# Upper case.
URBI_ENV_CPPFLAGS = -DURBI_ENV_$(shell echo "$(URBI_ENV)" | tr 'a-z' 'A-Z')

CPPFLAGS =							\
  @CPPFLAGS@ -I$(prefix)/include				\
  -I$(URBI_KERNEL_PATH)/gostai/kernel/include			\
  $(URBI_ENV_CPPFLAGS)
ALL_CPPFLAGS = $(PRE_CPPFLAGS) $(CPPFLAGS) $(EXTRA_CPPFLAGS)

# C.
CC = @CC@
CFLAGS = @CFLAGS@ $(SDK_CFLAGS)

# C++.
WARNING_CXXFLAGS = @WARNING_CXXFLAGS@
CXXFLAGS = $(WARNING_CXXFLAGS) @CXXFLAGS@ $(SDK_CXXFLAGS)
CXX = @CXX@

# Ld.
LD = @CC@
LIBS = $(SDK_LIBS)
LDFLAGS = @LDFLAGS@ @BOOST_THREAD_LDFLAGS@ $(SDK_LDFLAGS) -no-undefined

if URBI_ENV_AIBO
# Aibo.
MKBIN = @MKBIN@
MKBIN_FLAGS = @MKBIN_FLAGS@
OPEN_R_SDK = @OPEN_R_SDK@
OPEN_R_LDFLAGS = @OPEN_R_LDFLAGS@
STRIP = @STRIP@
endif

# Libtool.
LIBTOOL = $(hostdir)/libtool
HOBJECTS = $(OBJECTS:.o=.$(URBI_HOST).o)
LTOBJECTS = $(HOBJECTS:.o=.lo)
OUTBIN = nothing
OUTLIB = nothing2

# Commands to compile and link.  Inspired from Automake's.
COMPILE = $(CC) $(ALL_CPPFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) --tag=C --mode=compile $(COMPILE)
CXXCOMPILE = $(CXX) $(ALL_CPPFLAGS) $(CXXFLAGS)
LTCXXCOMPILE = $(LIBTOOL) --tag=CXX --mode=compile $(CXXCOMPILE)
CXXLINK = $(LIBTOOL) --tag=CXX --mode=link \
  $(CXX) $(CXXFLAGS) $(LDFLAGS) $(EXTRA_LDFLAGS)

# We use GNU Make pattern rules so that we can provide extra
# dependencies.  Before changing something, read the doc.
#
#    Suffix rules cannot have any prerequisites of their own.  If they
#    have any, they are treated as normal files with funny names, not as
#    suffix rules.  Thus, the rule:
#
#      .c.o: foo.h
#              $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
#
#    tells how to make the file `.c.o' from the prerequisite file `foo.h',
#    and is not at all like the pattern rule:
#
#      %.o: %.c foo.h
#              $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
#
#    which tells how to make `.o' files from `.c' files, and makes all `.o'
#    files using this pattern rule also depend on `foo.h'.
$(builddir)/%.$(URBI_HOST).lo: %.c $(HEADERS)
	$(LTCOMPILE) -c -o $@ $<

$(builddir)/%.$(URBI_HOST).lo: %.cc $(HEADERS)
	$(LTCXXCOMPILE) -c -o $@ $<

$(builddir)/%.$(URBI_HOST).lo: %.cpp $(HEADERS)
	$(LTCXXCOMPILE) -c -o $@ $<

# UObject target.
$(OUTLIB): $(LTOBJECTS) $(ARGUMENT_LIBS)
	$(CXXLINK) $(LTOBJECTS) $(ARGUMENT_LIBS) $(LIBS) -o $@

# I know no way to build shared libraries through libtool without a .la...
lalib = lib$(OUTSHLIB:$(SHLIBEXT)=.la)
libbase = $(OUTSHLIB:$(SHLIBEXT)=)
$(OUTSHLIB): $(LTOBJECTS) $(ARGUMENT_LIBS)
	$(CXXLINK) -export-dynamic -o $(lalib) \
	  $(LTOBJECTS) $(ARGUMENT_LIBS) $(LIBS) $(envdir)/libuobject.la -rpath $(hostdir)
	cp $$(ls .libs/lib$(libbase)*$(SHLIBEXT) | head -n 1) $(OUTSHLIB)
	rm -f $(lalib)

# The command to generate the library.
#
# We pass -whole-archive because there are global objects to be
# created that are not called by the main compilation units.  In that
# case the linker does not add these objects files in the result, and
# the final executable does not have the global objects contructed.
UMAKE_LINK = umake-link
LINK =						\
  $(UMAKE_LINK)					\
  --libtool='$(LIBTOOL)'			\
  --env='$(URBI_ENV)'				\
  --host='$(URBI_HOST)'				\
  --
$(OUTBIN): $(LTOBJECTS) $(ARGUMENT_LIBS)
if URBI_ENV_AIBO
	 $(LINK) \
            $(MKBIN) $(MKBIN_FLAGS) -o $@.BIN $(envdir)/URBI.ocf \
            $(envdir)/URBIStub.o $(ARGUMENT_LIBS) $(LTOBJECTS) \
	    $(envdir)/$(LIBNAME).la \
            $(OPEN_R_LDFLAGS) $(EXTRA_LDFLAGS)
	$(STRIP) $@.BIN
else
	$(LINK) \
	    $(CXX) $(CXXFLAGS) $(LDFLAGS) -o $@ \
	    $(ARGUMENT_LIBS) $(LIBS) $(LTOBJECTS) \
	    $(envdir)/$(LIBNAME).la $(UMAKE_EXTRALIB) \
	    $(EXTRA_LDFLAGS)
endif

clean:
	$(RM) *.lo *.o
